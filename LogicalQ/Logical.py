import copy
import numpy as np

from qiskit import QuantumRegister, AncillaRegister, ClassicalRegister, QuantumCircuit
from qiskit.circuit import Bit, Measure
from qiskit.circuit.classical import expr
from qiskit.quantum_info import Statevector, DensityMatrix, Pauli
from qiskit_addon_utils.slicing import slice_by_depth

class LogicalCircuit(QuantumCircuit):
    def __init__(
        self,
        n_logical_qubits,
        label,
        stabilizer_tableau,
        name=None,
    ):
        # Quantum error correcting code preparation
        self.n_logical_qubits = n_logical_qubits

        self.stabilizer_tableau = stabilizer_tableau
        self.n_stabilizers = len(self.stabilizer_tableau)

        self.n, self.k, self.d = label
        if any([len(stabilizer) != self.n for stabilizer in self.stabilizer_tableau]):
            raise ValueError(f"Code label n ({self.n}) does not match individual stabilizer length ({self.n_physical_qubits})")

        self.n_physical_qubits = self.n
        # @TODO - obtain an exact estimate for the number of ancilla qubits
        self.n_ancilla_qubits = self.n_stabilizers//2
        self.n_measure_qubits = self.n_ancilla_qubits

        self.flagged_stabilizers_1 = []
        self.flagged_stabilizers_2 = []
        self.x_stabilizers = []
        self.z_stabilizers = []

        # Generate the code, including its stabilizer groups
        self.generate_code()
        self.group_stabilizers()

        # Keep track of where QEC cycles are located in the circuit
        self.qec_cycle_indices_initial = {}
        self.qec_cycle_indices_final = {}

        self.logical_qregs = []
        self.ancilla_qregs = []
        self.logical_op_qregs = []
        self.enc_verif_cregs = []
        self.curr_syndrome_cregs = []
        self.prev_syndrome_cregs = []
        self.flagged_syndrome_diff_cregs = []
        self.unflagged_syndrome_diff_cregs = []
        self.pauli_frame_cregs = []
        self.logical_op_meas_cregs = []
        self.final_measurement_cregs = []

        self.qreg_lists = [
            self.logical_qregs,
            self.ancilla_qregs,
            self.logical_op_qregs,
        ]
        self.creg_lists = [
            self.enc_verif_cregs,
            self.curr_syndrome_cregs,
            self.prev_syndrome_cregs,
            self.flagged_syndrome_diff_cregs,
            self.unflagged_syndrome_diff_cregs,
            self.pauli_frame_cregs,
            self.logical_op_meas_cregs,
            self.final_measurement_cregs,
        ]

        # The underlying (empty) QuantumCircuit is generated by first calling super()...
        super().__init__(name=name)
        # ...then adding the logical qubits
        self.add_logical_qubits(self.n_logical_qubits)

        # Also add a classical measurement output register at the end
        self.output_creg = ClassicalRegister(self.n_logical_qubits, name="output")
        super().add_register(self.output_creg)

        # @TODO - find alternative, possibly by implementing upstream
        # Create setter qreg for purpose of setting classical bits dynamically
        self.cbit_setter_qreg = QuantumRegister(2, name="qsetter")
        self.add_register(self.cbit_setter_qreg)
        super().x(self.cbit_setter_qreg[1])

        self.data_without_qec = copy.deepcopy(self.data)

    # @TODO - this completely ignores QEC (besides encoding), do we want to have some sort of default QEC behavior?
    @classmethod
    def from_physical_circuit(cls, physical_circuit, label, stabilizer_tableau, name=None):
        logical_circuit = cls(physical_circuit.num_qubits, label, stabilizer_tableau, name)

        # @TODO - expose the options that encode takes to the user of from_physical_circuit
        logical_circuit.encode(range(physical_circuit.num_qubits), max_iterations=3)

        for i in range(len(physical_circuit.data)):
            circuit_instruction = physical_circuit.data[i]

            logical_circuit.append(circuit_instruction)

        return logical_circuit

    def add_logical_qubits(self, logical_qubit_count):
        current_logical_qubit_count = len(self.logical_qregs)

        for i in range(current_logical_qubit_count, current_logical_qubit_count + logical_qubit_count):
            # Physical qubits for logical qubit
            logical_qreg_i = QuantumRegister(self.n_physical_qubits, name=f"qlog{i}")
            # Ancilla qubits needed for measurements
            ancilla_qreg_i = AncillaRegister(self.n_ancilla_qubits, name=f"qanc{i}")
            # Ancilla qubits needed for logical operations
            logical_op_qreg_i = AncillaRegister(2, name=f"qlogical_op{i}")
            # Classical bits needed for encoding verification
            enc_verif_creg_i = ClassicalRegister(1, name=f"cenc_verif{i}")
            # Classical bits needed for measurements
            curr_syndrome_creg_i = ClassicalRegister(self.n_measure_qubits, name=f"ccurr_syndrome{i}")
            # Classical bits needed for previous syndrome measurements
            prev_syndrome_creg_i = ClassicalRegister(self.n_stabilizers, name=f"cprev_syndrome{i}")
            # Classical bits needed for flagged syndrome difference measurements
            flagged_syndrome_diff_creg_i = ClassicalRegister(self.n_stabilizers, name=f"cflagged_syndrome_diff{i}")
            # Classical bits needed for unflagged syndrome difference measurements
            unflagged_syndrome_diff_creg_i = ClassicalRegister(self.n_stabilizers, name=f"cunflagged_syndrome_diff{i}")
            # Classical bits needed to track the Pauli Frame
            pauli_frame_creg_i = ClassicalRegister(2, name=f"cpauli_frame{i}")
            # Classical bits needed to take measurements of logical operation qubits
            logical_op_meas_creg_i = ClassicalRegister(1, name=f"clogial_op_meas{i}")
            # Classical bits needed to take measurements of the final state of the logical qubit
            final_measurement_creg_i = ClassicalRegister(self.n_physical_qubits, name=f"cfinal_meas{i}")

            # Add new registers to storage lists
            self.logical_qregs.append(logical_qreg_i)
            self.ancilla_qregs.append(ancilla_qreg_i)
            self.logical_op_qregs.append(logical_op_qreg_i)
            self.enc_verif_cregs.append(enc_verif_creg_i)
            self.curr_syndrome_cregs.append(curr_syndrome_creg_i)
            self.prev_syndrome_cregs.append(prev_syndrome_creg_i)
            self.flagged_syndrome_diff_cregs.append(flagged_syndrome_diff_creg_i)
            self.unflagged_syndrome_diff_cregs.append(unflagged_syndrome_diff_creg_i)
            self.pauli_frame_cregs.append(pauli_frame_creg_i)
            self.logical_op_meas_cregs.append(logical_op_meas_creg_i)
            self.final_measurement_cregs.append(final_measurement_creg_i)

            # Add new registers to quantum circuit
            super().add_register(logical_qreg_i)
            super().add_register(ancilla_qreg_i)
            super().add_register(logical_op_qreg_i)
            super().add_register(enc_verif_creg_i)
            super().add_register(curr_syndrome_creg_i)
            super().add_register(prev_syndrome_creg_i)
            super().add_register(flagged_syndrome_diff_creg_i)
            super().add_register(unflagged_syndrome_diff_creg_i)
            super().add_register(pauli_frame_creg_i)
            super().add_register(logical_op_meas_creg_i)
            super().add_register(final_measurement_creg_i)

            # QEC cycle indices
            self.qec_cycle_indices_initial[i] = []
            self.qec_cycle_indices_final[i] = []

    ####################################
    ##### Quantum error correction #####
    ####################################

    def group_stabilizers(self):
        # @TODO - determine how stabilizers are generally selected for flagged measurements
        #       - the below is a heuristic which happens to work for the Steane code and potentially all CSS codes, but maybe not all stabilizer codes in general

        # Take the middle k stabilizers
        k = self.n_stabilizers//2
        self.flagged_stabilizers_1 = [s for s in range(self.n_stabilizers) if s < k - k//2 - 1 or s > k + k//2 - 1]
        self.flagged_stabilizers_2 = list(set(range(self.n_stabilizers)) - set(self.flagged_stabilizers_1))

        for i in range(self.n_stabilizers):
            if 'X' in self.stabilizer_tableau[i]:
                self.x_stabilizers.append(i)
            if 'Z' in self.stabilizer_tableau[i]:
                self.z_stabilizers.append(i)

    # Function which generates encoding circuit and logical operators for a given tableau
    def generate_code(self):
        m = len(self.stabilizer_tableau)

        # Step 1: Assemble generator matrix
        G = np.zeros((2, m, self.n))
        for i, stabilizer in enumerate(self.stabilizer_tableau):
            for j, pauli_j in enumerate(stabilizer):
                if pauli_j == "X":
                    G[0, i, j] = 1
                elif pauli_j == "Z":
                    G[1, i, j] = 1
                elif pauli_j == "Y":
                    G[:, i, j] = 1

        # Step 2: Perform Gaussian reduction in base 2
        row = 0
        for col in range(self.n):
            pivot_row = None
            for i in range(row, m):
                if G[0, i, col] == 1:
                    pivot_row = i
                    break

            if pivot_row is None:
                continue

            G[:, [row, pivot_row]] = G[:, [pivot_row, row]]

            # Flip any other rows with a "1" in the same column
            for i in range(m):
                if i != row and G[0, i, col] == 1:
                    G[:, i] = G[:, i].astype(int) ^ G[:, row].astype(int)
                    # G[0, i] = G[0, i].astype(int) ^ G[0, row].astype(int)
                    # G[1, i] = G[1, i].astype(int) ^ G[1, row].astype(int)

            # Move to the next row, if we haven't reached the end of the matrix
            row += 1
            if row >= m:
                break

        r = np.linalg.matrix_rank(G[0])

        E = np.copy(G[:, r:, r:])
        row = 0
        for col in range(self.n-r):
            pivot_row = None
            for i in range(row, m-r):
                if E[1, i, col] == 1:
                    pivot_row = i
                    break

            if pivot_row is None:
                continue

            E[:, [row, pivot_row]] = E[:, [pivot_row, row]]
            G[:, [r+row, r+pivot_row]] = G[:, [r+pivot_row, r+row]]

            # Flip any other rows with a "1" in the same column
            for i in range(m-r):
                if i != row and E[1, i, col] == 1:
                    E[:, i] = E[:, i].astype(int) ^ E[:, row].astype(int)
                    G[:, r+i] = G[:, r+i].astype(int) ^ G[:, r+row].astype(int)

            # Move to the next row, if we haven't reached the end of the matrix
            row += 1
            if row >= m:
                break

        self.G = G

        # Step 3: Construct logical operators using Pauli vector representations due to Gottesmann (1997)
        r = np.linalg.matrix_rank(self.G[0])
        A_2 = self.G[0, 0:r, m:self.n] # r x k
        C_1 = self.G[1, 0:r, r:m] # r x m-r
        C_2 = self.G[1, 0:r, m:self.n] # r x k
        E_2 = self.G[1, r:m, m:self.n] # m-r x k

        self.LogicalXVector = np.block([
            [[np.zeros((self.k, r)), E_2.T,                        np.eye(self.k, self.k)    ]],
            [[E_2.T @ C_1.T + C_2.T,      np.zeros((self.k, m-r)), np.zeros((self.k, self.k))]]
        ])

        # Create Logical X circuit corresponding to X's and Z's at 1's in Pauli vector
        self.LogicalXCircuit = QuantumCircuit(self.n)
        for i in range(self.k):
            # X part
            for q, bit in enumerate(self.LogicalXVector[0][i]):
                if bit == 1:
                    self.LogicalXCircuit.x(q)
            # Z part
            for q, bit in enumerate(self.LogicalXVector[1][i]):
                if bit == 1:
                    self.LogicalXCircuit.z(q)
        self.LogicalXGate = self.LogicalXCircuit.to_gate(label="$X_L$")

        self.LogicalZVector = np.block([
            [[np.zeros((self.k, r)), np.zeros((self.k, m-r)), np.zeros((self.k, self.k))]],
            [[A_2.T,                 np.zeros((self.k, m-r)), np.eye(self.k, self.k)    ]]
        ])

        # Create Logical Z circuit corresponding to X's and Z's at 1's in Pauli vector
        self.LogicalZCircuit = QuantumCircuit(self.n)
        for i in range(self.k):
            # X part
            for q, bit in enumerate(self.LogicalZVector[0][i]):
                if bit == 1:
                    self.LogicalZCircuit.x(q)
            # Z part
            for q, bit in enumerate(self.LogicalZVector[1][i]):
                if bit == 1:
                    self.LogicalZCircuit.z(q)
        self.LogicalZGate = self.LogicalZCircuit.to_gate(label="$Z_L$")

        self.LogicalYCircuit = self.LogicalXCircuit.compose(self.LogicalZCircuit)
        self.LogicalYGate = self.LogicalYCircuit.to_gate(label="$Y_L$")

        # Create Logical H circuit using Childs and Wiebe's linear combination of unitaries method
        self.LogicalHCircuit_LCU = QuantumCircuit(self.n + 1)
        self.LogicalHCircuit_LCU.h(self.n)
        self.LogicalHCircuit_LCU.compose(self.LogicalXCircuit.control(1), [self.n, *list(range(self.n))], inplace=True)
        self.LogicalHCircuit_LCU.x(self.n)
        self.LogicalHCircuit_LCU.compose(self.LogicalZCircuit.control(1), [self.n, *list(range(self.n))], inplace=True)
        self.LogicalHCircuit_LCU.x(self.n)
        self.LogicalHCircuit_LCU.h(self.n)
        self.LogicalHGate_LCU = self.LogicalHCircuit_LCU.to_gate(label="$H_L$")

        # Creates Logical H circuit using coherent feedback
        self.LogicalHCircuit_CF = QuantumCircuit(self.n + 1)
        self.LogicalHCircuit_CF.h(self.n)
        self.LogicalHCircuit_CF.compose(self.LogicalXCircuit.control(1), [self.LogicalHCircuit_CF.qubits[self.n]] + self.LogicalHCircuit_CF.qubits[:self.n], inplace=True)
        self.LogicalHCircuit_CF.compose(self.LogicalZCircuit.control(1), [self.LogicalHCircuit_CF.qubits[self.n]] + self.LogicalHCircuit_CF.qubits[:self.n], inplace=True)
        self.LogicalHCircuit_CF.h(self.n)
        self.LogicalHCircuit_CF.compose(self.LogicalXCircuit.control(1), [self.LogicalHCircuit_CF.qubits[self.n]] + self.LogicalHCircuit_CF.qubits[:self.n], inplace=True)
        self.LogicalHCircuit_CF.x(self.n)
        self.LogicalHCircuit_CF.compose(self.LogicalZCircuit.control(1), [self.LogicalHCircuit_CF.qubits[self.n]] + self.LogicalHCircuit_CF.qubits[:self.n], inplace=True)
        self.LogicalHCircuit_CF.h(self.n)
        self.LogicalHGate_CF = self.LogicalHCircuit_CF.to_gate(label="$H_{CF}$")

        # @TODO - Logical S
        # Creates Logical S circuit using coherent feedback
        self.LogicalSCircuit_CF = QuantumCircuit(self.n + 1)
        self.LogicalSCircuit_CF.h(self.n)
        self.LogicalSCircuit_CF.s(self.n)
        self.LogicalSCircuit_CF.h(self.n)
        self.LogicalSCircuit_CF.compose(self.LogicalZCircuit.control(1), [self.LogicalSCircuit_CF.qubits[self.n]] + self.LogicalSCircuit_CF.qubits[:self.n], inplace=True)
        self.LogicalSCircuit_CF.h(self.n)
        self.LogicalSCircuit_CF.compose(self.LogicalZCircuit.control(1), [self.LogicalSCircuit_CF.qubits[self.n]] + self.LogicalSCircuit_CF.qubits[:self.n], inplace=True)
        self.LogicalSCircuit_CF.sdg(self.n)
        self.LogicalSCircuit_CF.h(self.n)
        self.LogicalSGate_CF = self.LogicalSCircuit_CF.to_gate(label="$S_{CF}$")

        # @TODO - Logical S†
        # Creates Logical S† circuit using coherent feedback
        self.LogicalSdgCircuit_CF = QuantumCircuit(self.n + 1)
        self.LogicalSdgCircuit_CF.h(self.n)
        self.LogicalSdgCircuit_CF.sdg(self.n)
        self.LogicalSdgCircuit_CF.h(self.n)
        self.LogicalSdgCircuit_CF.compose(self.LogicalZCircuit.control(1), [self.LogicalSdgCircuit_CF.qubits[self.n]] + self.LogicalSdgCircuit_CF.qubits[:self.n], inplace=True)
        self.LogicalSdgCircuit_CF.h(self.n)
        self.LogicalSdgCircuit_CF.compose(self.LogicalZCircuit.control(1), [self.LogicalSdgCircuit_CF.qubits[self.n]] + self.LogicalSdgCircuit_CF.qubits[:self.n], inplace=True)
        self.LogicalSdgCircuit_CF.s(self.n)
        self.LogicalSdgCircuit_CF.h(self.n)
        self.LogicalSdgGate_CF = self.LogicalSdgCircuit_CF.to_gate(label="$S†_{CF}$")

        # @TODO - Logical T
        # Creates Logical T circuit using coherent feedback
        self.LogicalTCircuit_CF = QuantumCircuit(self.n + 2)
        self.LogicalTCircuit_CF.h(self.n)
        self.LogicalTCircuit_CF.h(self.n + 1)
        self.LogicalTCircuit_CF.t(self.n)
        self.LogicalTCircuit_CF.s(self.n + 1)
        self.LogicalTCircuit_CF.h(self.n)
        self.LogicalTCircuit_CF.compose(self.LogicalZCircuit.control(1), [self.LogicalTCircuit_CF.qubits[self.n]] + self.LogicalTCircuit_CF.qubits[:self.n], inplace=True)
        self.LogicalTCircuit_CF.h(self.n)
        self.LogicalTCircuit_CF.h(self.n + 1)
        self.LogicalTCircuit_CF.compose(self.LogicalZCircuit.control(2), self.LogicalTCircuit_CF.qubits[self.n:self.n+2] + self.LogicalTCircuit_CF.qubits[:self.n], inplace=True)
        self.LogicalTCircuit_CF.h(self.n + 1)
        self.LogicalTCircuit_CF.compose(self.LogicalZCircuit.control(2), self.LogicalTCircuit_CF.qubits[self.n:self.n+2] + self.LogicalTCircuit_CF.qubits[:self.n], inplace=True)
        self.LogicalTCircuit_CF.tdg(self.n)
        self.LogicalTCircuit_CF.sdg(self.n + 1)
        self.LogicalTCircuit_CF.h(self.n)
        self.LogicalTCircuit_CF.h(self.n + 1)
        self.LogicalTGate_CF = self.LogicalTCircuit_CF.to_gate(label="$T_{CF}$")

        # @TODO - Logical T†
        # Creates Logical T† circuit using coherent feedback
        self.LogicalTdgCircuit_CF = QuantumCircuit(self.n + 2)
        self.LogicalTdgCircuit_CF.h(self.n)
        self.LogicalTdgCircuit_CF.h(self.n + 1)
        self.LogicalTdgCircuit_CF.tdg(self.n)
        self.LogicalTdgCircuit_CF.sdg(self.n + 1)
        self.LogicalTdgCircuit_CF.h(self.n)
        self.LogicalTdgCircuit_CF.compose(self.LogicalZCircuit.control(1), [self.LogicalTdgCircuit_CF.qubits[self.n]] + self.LogicalTdgCircuit_CF.qubits[:self.n], inplace=True)
        self.LogicalTdgCircuit_CF.h(self.n)
        self.LogicalTdgCircuit_CF.h(self.n + 1)
        self.LogicalTdgCircuit_CF.compose(self.LogicalZCircuit.control(2), self.LogicalTdgCircuit_CF.qubits[self.n:self.n+2] + self.LogicalTdgCircuit_CF.qubits[:self.n], inplace=True)
        self.LogicalTdgCircuit_CF.h(self.n + 1)
        self.LogicalTdgCircuit_CF.compose(self.LogicalZCircuit.control(2), self.LogicalTdgCircuit_CF.qubits[self.n:self.n+2] + self.LogicalTdgCircuit_CF.qubits[:self.n], inplace=True)
        self.LogicalTdgCircuit_CF.t(self.n)
        self.LogicalTdgCircuit_CF.s(self.n + 1)
        self.LogicalTdgCircuit_CF.h(self.n)
        self.LogicalTdgCircuit_CF.h(self.n + 1)
        self.LogicalTdgGate_CF = self.LogicalTdgCircuit_CF.to_gate(label="$T†_{CF}$")

        # @TODO - Logical CX

        # Step 4: Apply the respective stabilizers
        self.encoding_circuit = QuantumCircuit(self.n)
        for i in range(self.k):
            for j in range(r, self.n-self.k):
                if self.LogicalXVector[0, i, j]:
                    self.encoding_circuit.cx(self.n-self.k+i, j)

        for i in range(r):
            self.encoding_circuit.h(i)
            for j in range(self.n):
                if i != j:
                    if self.G[0, i, j]:
                        self.encoding_circuit.cx(i, j)
                    elif self.G[1, i, j]:
                        self.encoding_circuit.cz(i, j)
                    elif self.G[0, i, j] and self.G[1, i, j]:
                        self.encoding_circuit.cx(i, j)
                        self.encoding_circuit.cz(i, j)

        self.encoding_gate = self.encoding_circuit.to_gate(label="$U_{enc}$")

    # Encodes logical qubits for a given number of iterations
    def encode(self, *qubits, max_iterations=1, initial_states=None):
        """
        Prepare logical qubit(s) in the specified initial state
        """

        if self.encoding_circuit is None:
            raise RuntimeError("LogicalCircuit code has not been properly constructed (missing encoding circuit)")

        if qubits is None or (hasattr(qubits, "__iter__") and len(qubits) == 0):
            raise ValueError("No qubits specified for logical state encoding")
        else:
            if len(qubits) > 0 and hasattr(qubits[0], "__iter__"):
                # Double unwrapping in case qubits is actually a list of lists
                qubits = [qj for qi in qubits for qj in qi]
            else:
                # Simple list conversion to guarantee type
                qubits = list(qubits)

        if initial_states is None:
            initial_states = [0] * len(qubits)

        if initial_states is None or len(qubits) != len(initial_states):
            raise ValueError("Number of qubits should equal number of initial states if initial states are provided")

        for q, init_state in zip(qubits, initial_states):
            with self.box(label="logical.qec.encode:$\\hat U_{enc}$"):
                # Preliminary physical qubit reset
                super().reset(self.logical_qregs[q])

                # Initial encoding
                super().compose(self.encoding_circuit, self.logical_qregs[q], inplace=True)

                # CNOT from physical qubits to ancilla(e)
                super().cx(self.logical_qregs[q][1], self.ancilla_qregs[q][0])
                super().cx(self.logical_qregs[q][3], self.ancilla_qregs[q][0])
                super().cx(self.logical_qregs[q][5], self.ancilla_qregs[q][0])

                # Measure ancilla(e)
                # super().measure(self.ancilla_qregs[q][0], self.enc_verif_cregs[q][0])
                super().append(Measure(), [self.ancilla_qregs[q][0]], [self.enc_verif_cregs[q][0]], copy=False)

                for _ in range(max_iterations - 1):
                    # If the ancilla stores a 1, reset the entire logical qubit and redo
                    with super().if_test((self.enc_verif_cregs[q][0], 1)):
                        super().reset(self.logical_qregs[q])

                        # Initial encoding
                        super().compose(self.encoding_circuit, self.logical_qregs[q], inplace=True)

                        # CNOT from (Z1 Z3 Z5) to ancilla
                        super().cx(self.logical_qregs[q][1], self.ancilla_qregs[q][0])
                        super().cx(self.logical_qregs[q][3], self.ancilla_qregs[q][0])
                        super().cx(self.logical_qregs[q][5], self.ancilla_qregs[q][0])

                        # Measure ancilla
                        # super().measure(self.ancilla_qregs[q][0], self.enc_verif_cregs[q][0])
                        super().append(Measure(), [self.ancilla_qregs[q][0]], [self.enc_verif_cregs[q][0]], copy=False)

                # Reset ancilla qubit
                super().reset(self.ancilla_qregs[q][0])

                # Flip qubits if necessary
                if init_state == 1:
                    self.x(q)
                elif init_state != 0:
                    raise ValueError("Initial state should be either 0 or 1 (arbitrary statevectors not yet supported)!")

        return True

    # Reset all ancillas associated with specified logical qubits
    def reset_ancillas(self, logical_qubit_indices=None):
        if logical_qubit_indices is None or len(logical_qubit_indices) == 0:
            logical_qubit_indices = list(range(self.n_logical_qubits))

        for q in logical_qubit_indices:
            self.reset(self.ancilla_qregs[q])

    def steane_flagged_circuit1(self, logical_qubit_indices):
        for q in logical_qubit_indices:
            super().barrier()
            super().h(self.ancilla_qregs[q][0])
            super().cx(self.ancilla_qregs[q][0], self.logical_qregs[q][3])
            super().cx(self.logical_qregs[q][2], self.ancilla_qregs[q][2])
            super().cx(self.logical_qregs[q][5], self.ancilla_qregs[q][1])
            super().cx(self.ancilla_qregs[q][0], self.ancilla_qregs[q][1])
            super().cx(self.ancilla_qregs[q][0], self.logical_qregs[q][0])
            super().cx(self.logical_qregs[q][3], self.ancilla_qregs[q][2])
            super().cx(self.logical_qregs[q][4], self.ancilla_qregs[q][1])
            super().cx(self.ancilla_qregs[q][0], self.logical_qregs[q][1])
            super().cx(self.logical_qregs[q][6], self.ancilla_qregs[q][2])
            super().cx(self.logical_qregs[q][2], self.ancilla_qregs[q][1])
            super().cx(self.ancilla_qregs[q][0], self.ancilla_qregs[q][2])
            super().cx(self.ancilla_qregs[q][0], self.logical_qregs[q][2])
            super().cx(self.logical_qregs[q][5], self.ancilla_qregs[q][2])
            super().cx(self.logical_qregs[q][1], self.ancilla_qregs[q][1])
            super().h(self.ancilla_qregs[q][0])
            super().barrier()

    def steane_flagged_circuit2(self, logical_qubit_indices):
        for q in logical_qubit_indices:
            super().barrier()
            super().h(self.ancilla_qregs[q][1])
            super().h(self.ancilla_qregs[q][2])
            super().cx(self.logical_qregs[q][3], self.ancilla_qregs[q][0])
            super().cx(self.ancilla_qregs[q][2], self.logical_qregs[q][2])
            super().cx(self.ancilla_qregs[q][1], self.logical_qregs[q][5])
            super().cx(self.ancilla_qregs[q][1], self.ancilla_qregs[q][0])
            super().cx(self.logical_qregs[q][0], self.ancilla_qregs[q][0])
            super().cx(self.ancilla_qregs[q][2], self.logical_qregs[q][3])
            super().cx(self.ancilla_qregs[q][1], self.logical_qregs[q][4])
            super().cx(self.logical_qregs[q][1], self.ancilla_qregs[q][0])
            super().cx(self.ancilla_qregs[q][2], self.logical_qregs[q][6])
            super().cx(self.ancilla_qregs[q][1], self.logical_qregs[q][2])
            super().cx(self.ancilla_qregs[q][2], self.ancilla_qregs[q][0])
            super().cx(self.logical_qregs[q][2], self.ancilla_qregs[q][0])
            super().cx(self.ancilla_qregs[q][2], self.logical_qregs[q][5])
            super().cx(self.ancilla_qregs[q][1], self.logical_qregs[q][1])
            super().h(self.ancilla_qregs[q][1])
            super().h(self.ancilla_qregs[q][2])
            super().barrier()

    # Measure specified specifiers to the circuit as controlled Pauli operators
    def measure_stabilizers(self, logical_qubit_indices=None, stabilizer_indices=None):
        if logical_qubit_indices is None or len(logical_qubit_indices) == 0:
            logical_qubit_indices = list(range(self.n_logical_qubits))

        if stabilizer_indices is None or len(logical_qubit_indices) == 0:
            stabilizer_indices = list(range(self.n_stabilizers))

        for q in logical_qubit_indices:
            for s, stabilizer_index in enumerate(stabilizer_indices):

                stabilizer = self.stabilizer_tableau[stabilizer_index]
                super().h(self.ancilla_qregs[q][s])
                for p in range(self.n_physical_qubits):
                    stabilizer_pauli = Pauli(stabilizer[p])
                    if stabilizer[p] != 'I':
                        CPauliInstruction = stabilizer_pauli.to_instruction().control(1)
                        super().append(CPauliInstruction, [self.ancilla_qregs[q][s], self.logical_qregs[q][p]])
                super().h(self.ancilla_qregs[q][s])

    # Measure flagged or unflagged syndrome differences for specified logical qubits and stabilizers
    def measure_syndrome_diff(self, logical_qubit_indices=None, stabilizer_indices=None, flagged=False, steane_flag_1=False, steane_flag_2=False):
        if logical_qubit_indices is None or len(logical_qubit_indices) == 0:
            logical_qubit_indices = list(range(self.n_logical_qubits))

        if stabilizer_indices is None or len(stabilizer_indices) == 0:
            stabilizer_indices = list(range(self.n_stabilizers))

        for q in logical_qubit_indices:
            syndrome_diff_creg = self.flagged_syndrome_diff_cregs[q] if flagged else self.unflagged_syndrome_diff_cregs[q]

            # Apply and measure stabilizers for the desired syndrome
            if steane_flag_1:
                self.steane_flagged_circuit1(logical_qubit_indices)
            elif steane_flag_2:
                self.steane_flagged_circuit2(logical_qubit_indices)
            else:
                self.measure_stabilizers(logical_qubit_indices=[q], stabilizer_indices=stabilizer_indices)
            for n in range(self.n_ancilla_qubits):
                # super().measure(self.ancilla_qregs[q][n], self.curr_syndrome_cregs[q][n])
                super().append(Measure(), [self.ancilla_qregs[q][n]], [self.curr_syndrome_cregs[q][n]], copy=False)

            # Determine the syndrome difference
            for n in range(len(stabilizer_indices)):
                with self.if_test(self.cbit_xor([self.curr_syndrome_cregs[q][n], self.prev_syndrome_cregs[q][stabilizer_indices[n]]])) as _else:
                    self.set_cbit(syndrome_diff_creg[stabilizer_indices[n]], 1)
                with _else:
                    self.set_cbit(syndrome_diff_creg[stabilizer_indices[n]], 0)

        self.reset_ancillas(logical_qubit_indices=logical_qubit_indices)

    # Compute optimal QEC cycle indices and perform insertion (unless specified otherwise)
    def optimize_qec_cycle_indices(self, logical_qubit_indices=None, constraint_model=None, ignore_existing_qec=False, clear_existing_qec=False):
        if logical_qubit_indices is None or len(logical_qubit_indices) == 0:
            logical_qubit_indices = list(range(self.n_logical_qubits))

        if clear_existing_qec and not ignore_existing_qec:
            raise ValueError("Clear existing QEC requested but not ignore existing QEC, which is likely to result in index errors because existing QEC cycles are cleared before new ones are inserted at the computed indices")

        # @TODO - if the user has requested that QEC be ignored, check whether there are any QEC-related parameters in the constraint_model

        slices = slice_by_depth(self, 1)
        depths = []
        for d, slice in enumerate(slices):
            depths.extend([d]*len(slice.data))

        new_qec_cycle_indices_initial = {}
        def compute_instruction_contributions(q, i, d, instruction, counters, running_cost):
            # Ignore certain "trivial" operations
            if instruction.name in ["barrier"]:
                return False

            # Ignore QEC steps (e.g. encoding, QEC cycles)
            if instruction.label is not None and instruction.label.startswith("logical.qec"):
                return False

            met = False

            # If in a ControlFlowOp, loop over the instructions in the data
            if instruction.is_control_flow():
                for param in instruction.params:
                    if isinstance(param, QuantumCircuit):
                        for sub_instruction in param:
                            met = met or compute_instruction_contributions(q, i, d, sub_instruction, counters, running_cost)

            # @TODO - handle controlled gates
            if instruction.is_controlled_gate():
                if not instruction.is_standard_gate():
                    print(f"WARNING - Non-Qiskit standard controlled gate with name '{instruction.name}' and label '{instruction.label}' identified, costs may not be accurate")

            # @TODO - unsure whether this is implemented correctly
            if "circuit_depth_logical_qubit" in constraint_model.keys():
                if (d - d[new_qec_cycle_indices_initial[q][-1]]) >= constraint_model["circuit_depth_logical_qubit"]:
                    met = True

            # Check instruction-specific criteria
            if f"num_{instruction.name}" in constraint_model.keys():
                counters[f"num_{instruction.name}"] = counters.get(f"num_{instruction.name}", 0) + 1
                met = met or counters[f"num_{instruction.name}"] >= constraint_model[f"num_{instruction.name}"]
            if f"cost_{instruction.name}" in constraint_model.keys():
                running_cost[-1] += constraint_model[f"cost_{instruction.name}"]

            if f"num_ops_{len(instruction.qubits)}q" in constraint_model.keys():
                counters[f"num_ops_{len(instruction.qubits)}q"] = counters.get(f"num_ops_{len(instruction.qubits)}q", 0) + 1
                met = met or counters[f"num_ops_{len(instruction.qubits)}q"] >= constraint_model[f"num_ops_{len(instruction.qubits)}q"]
            if f"cost_ops_{len(instruction.qubits)}q" in constraint_model.keys():
                running_cost[-1] += constraint_model[f"cost_ops_{len(instruction.qubits)}q"]

            # @TODO - check key "num_ops_clifford"
            # @TODO - check key "cost_ops_clifford"
            # @TODO - check key "num_ops_non_clifford"
            # @TODO - check key "cost_ops_non_clifford"
            # @TODO - check key "num_logical_ops_transversal"
            # @TODO - check key "cost_logical_ops_transversal"
            # @TODO - check key "num_logical_ops_non_transversal"
            # @TODO - check key "cost_logical_ops_non_transversal"
            # @TODO - check key "circuit_depth_logical_qubit"
            # @TODO - check key "cost_circuit_depth_logical_qubit"
            # @TODO - check key "cost_circuit_depth_logical_circuit"

            return met

        for q in logical_qubit_indices:
            # Counters track constraints which are contributed to and met separately when any one reaches its limit
            counters = {}
            # Running costs tracks collective constraints which sum over contributions from many sources, which must remain below the effective threshold
            running_cost = [0.0]

            for i, (d, instruction) in enumerate(zip(depths, self.data)):
                # Check whether instruction involves logical qubit
                instruction_involves_logical_qubit = False
                for qreg_list in self.qreg_lists:
                    qreg = qreg_list[q]
                    if any([qubit in instruction.qubits for qubit in qreg]):
                        instruction_involves_logical_qubit = True

                    if instruction_involves_logical_qubit:
                        break

                if not instruction_involves_logical_qubit:
                    continue

                met = compute_instruction_contributions(q, i, d, instruction, counters, running_cost)

                # print(counters, running_cost[-1])

                met = met or np.isclose(running_cost[-1], constraint_model["effective_threshold"])
                if met:
                    # print(f"Inserting QEC cycle at index {i}, depth {d}")
                    new_qec_cycle_indices_initial[q] = new_qec_cycle_indices_initial.get(q, []) + [i]

                    # Reset counters and running cost
                    counters = {}
                    running_cost[-1] = 0.0

                    break

        return new_qec_cycle_indices_initial

    # Insert QEC cycles at specified indices in the circuit data
    # @TODO - Extend the method to process qubit-specific indices for user-friendliness
    def insert_qec_cycles(self, logical_qubit_indices=None, qec_cycle_indices=None, clear_existing_qec=False):
        # Carefully perform all checks beforehand because it's very difficult to catch errors mid-execution

        if logical_qubit_indices is None or len(logical_qubit_indices) == 0:
            if isinstance(qec_cycle_indices, dict):
                logical_qubit_indices = qec_cycle_indices.keys()
            else:
                logical_qubit_indices = list(range(self.n_logical_qubits))

        if isinstance(qec_cycle_indices, dict):
            if set(logical_qubit_indices) != set(qec_cycle_indices.keys()):
                raise ValueError("qec_cycle_indices is a dict but its set of keys does not equal the list logical_qubit_indices")
        elif isinstance(qec_cycle_indices, list):
            if len(logical_qubit_indices) != len(qec_cycle_indices):
                raise ValueError("qec_cycle_indices is a list but its length does not equal length of list logical_qubit_indices")

            qec_cycle_indices = dict(zip(logical_qubit_indices, qec_cycle_indices))

        for q, qec_cycle_indices_q in qec_cycle_indices.items():
            if not hasattr(qec_cycle_indices_q, "__iter__"):
                raise ValueError(f"QEC cycle indices input for logical qubit {q} is {type(qec_cycle_indices_q)}, list expected.")

            if any([not isinstance(index, int) for index in qec_cycle_indices_q]):
                raise ValueError(f"QEC cycle indices input for logical qubit {q} is {type(qec_cycle_indices_q)}, list expected.")

        # "Transpose" dictionary
        qec_cycle_indices_T = {}
        # For each key (logical qubit index) and value list (list of QEC cycle indices for the logical qubit)...
        for key, value_list in qec_cycle_indices.items():
            # ...and for each value (QEC cycle index) in the value list (list of QEC cycle indices for this logical qubit)...
            for value in value_list:
                # ...append the key (logical qubit index) to the transposed dictionary for this value (QEC cycle index)!
                qec_cycle_indices_T[value] = qec_cycle_indices_T.get(value, []) + [key]

        # If requested, remove QEC cycles (only full-clear supported)
        if clear_existing_qec:
            self.clear_qec_cycles()

        # Deepcopy current circuit data
        _data = copy.deepcopy(self.data)

        # Reconstruct circuit, appending QEC cycles along the way when needed
        self.data = []
        for i in range(len(_data)):
            # If current index is a key in transposed dictionary, append QEC cycles for corresponding values (logical qubit indices)
            if i in qec_cycle_indices_T:
                ret = self.append_qec_cycle(qec_cycle_indices_T[i])

            # Append original circuit data
            self.data.append(_data[i])

        return _data, self.data

    # Append a QEC cycle to the end of the circuit
    def append_qec_cycle(self, logical_qubit_indices=None):
        # Use hardcoded flagged circuits for Steane code
        use_steane_flagged_circuits = True if (self.n, self.k, self.d) == (7,1,3) else False

        if logical_qubit_indices is None or len(logical_qubit_indices) == 0:
            logical_qubit_indices = list(range(self.n_logical_qubits))

        for q in logical_qubit_indices:
            if len(self.data_without_qec) is None:
                self.data_without_qec = copy.deepcopy(self.data)
            else:
                if len(self.qec_cycle_indices_final[q]) > 0:
                    last_qec_index_final = self.qec_cycle_indices_final[q][-1]
                else:
                    last_qec_index_final = -1

                self.data_without_qec.extend(self.data[last_qec_index_final+1:])

            # Keep track of the initial index for now, only append at the end once we know this call was successful
            index_initial = len(self.data)

            with self.box(label="logical.qec.qec_cycle:$\\hat U_{QEC}$"):
                super().reset(self.ancilla_qregs[q])

                # Perform first flagged syndrome measurements
                self.measure_syndrome_diff(logical_qubit_indices=[q], stabilizer_indices=self.flagged_stabilizers_1, flagged=True, steane_flag_1=use_steane_flagged_circuits)

                # If no change in syndrome, perform second flagged syndrome measurement
                with self.if_test(expr.equal(self.flagged_syndrome_diff_cregs[q], 0)):
                    self.measure_syndrome_diff(logical_qubit_indices=[q], stabilizer_indices=self.flagged_stabilizers_2, flagged=True, steane_flag_2=use_steane_flagged_circuits)

                # If change in syndrome, perform unflagged syndrome measurement, decode, and correct
                with self.if_test(expr.not_equal(self.flagged_syndrome_diff_cregs[q], 0)):
                    self.measure_syndrome_diff(logical_qubit_indices=[q], stabilizer_indices=self.x_stabilizers, flagged=False)
                    self.measure_syndrome_diff(logical_qubit_indices=[q], stabilizer_indices=self.z_stabilizers, flagged=False)

                    self.apply_decoding(logical_qubit_indices=[q], stabilizer_indices=self.x_stabilizers, with_flagged=False)
                    self.apply_decoding(logical_qubit_indices=[q], stabilizer_indices=self.z_stabilizers, with_flagged=False)
                    self.apply_decoding(logical_qubit_indices=[q], stabilizer_indices=self.x_stabilizers, with_flagged=True)
                    self.apply_decoding(logical_qubit_indices=[q], stabilizer_indices=self.z_stabilizers, with_flagged=True)

                    # Update previous syndrome
                    for n in range(self.n_stabilizers):
                        with self.if_test(expr.lift(self.unflagged_syndrome_diff_cregs[q][n])):
                            self.cbit_not(self.prev_syndrome_cregs[q][n])

            index_final = len(self.data)-1

            self.qec_cycle_indices_initial[q].append(index_initial)
            self.qec_cycle_indices_final[q].append(index_final)

        return self.qec_cycle_indices_initial, self.qec_cycle_indices_final

    # Clear QEC cycles (either specified or all) on specified logical qubits
    def clear_qec_cycles(self, logical_qubit_indices=None, qec_cycle_indices=None):
        return NotImplementedError("clear_qec_cycles is not yet implemented")

    # @TODO - determine appropriate syndrome decoding mappings dynamically
    def apply_decoding(self, logical_qubit_indices, stabilizer_indices, with_flagged):
        for q in logical_qubit_indices:
            syn_diff = [self.unflagged_syndrome_diff_cregs[q][x] for x in stabilizer_indices]
            # Determines index of pauli frame to be modified
            pf_ind = 0 if 'X' in self.stabilizer_tableau[stabilizer_indices[0]] else 1

            # Decoding sequence with flagged syndrome
            if with_flagged:
                flag_diff = [self.flagged_syndrome_diff_cregs[q][x] for x in stabilizer_indices]
                with super().if_test(expr.bit_and(self.cbit_and(flag_diff, [1, 0, 0]), self.cbit_and(syn_diff, [0, 1, 0]))):
                    self.cbit_not(self.pauli_frame_cregs[q][pf_ind])
                with super().if_test(expr.bit_and(self.cbit_and(flag_diff, [1, 0, 0]), self.cbit_and(syn_diff, [0, 0, 1]))):
                    self.cbit_not(self.pauli_frame_cregs[q][pf_ind])
                with super().if_test(expr.bit_and(self.cbit_and(flag_diff, [0, 1, 1]), self.cbit_and(syn_diff, [0, 0, 1]))):
                    self.cbit_not(self.pauli_frame_cregs[q][pf_ind])

            # Unflagged decoding sequence
            else:
                with super().if_test(self.cbit_and(syn_diff, [0, 1, 0])):
                    self.cbit_not(self.pauli_frame_cregs[q][pf_ind])
                with super().if_test(self.cbit_and(syn_diff, [0, 1, 1])):
                    self.cbit_not(self.pauli_frame_cregs[q][pf_ind])
                with super().if_test(self.cbit_and(syn_diff, [0, 0, 1])):
                    self.cbit_not(self.pauli_frame_cregs[q][pf_ind])

    def measure(self, logical_qubit_indices, cbit_indices, with_error_correction=True):
        if not hasattr(logical_qubit_indices, "__iter__"):
            raise ValueError("Logical qubit indices must be an iterable!")

        if not hasattr(cbit_indices, "__iter__"):
            raise ValueError("Classical bit indices must be an iterable!")

        if len(logical_qubit_indices) != len(cbit_indices):
            raise ValueError("Number of qubits should equal number of classical bits")

        for q, c in zip(logical_qubit_indices, cbit_indices):
            # Measurement of state
            for n in range(self.n_physical_qubits):
                # super().measure(self.logical_qregs[q][n], self.final_measurement_cregs[q][n])
                super().append(Measure(), [self.logical_qregs[q][n]], [self.final_measurement_cregs[q][n]], copy=False)

            # @TODO - use LogicalXVector instead
            with super().if_test(self.cbit_xor([self.final_measurement_cregs[q][x] for x in [4,5,6]])):
                self.set_cbit(self.output_creg[c], 1)

            if with_error_correction:
                # Final syndrome
                for n in range(self.n_ancilla_qubits):
                    stabilizer = self.stabilizer_tableau[self.z_stabilizers[n]]
                    s_indices = []
                    for i in range(len(stabilizer)):
                        if stabilizer[i] == 'Z':
                            s_indices.append(i)

                    with super().if_test(self.cbit_xor([self.final_measurement_cregs[q][z] for z in s_indices])):
                        self.set_cbit(self.curr_syndrome_cregs[q][n], 1)

                # Final syndrome diff
                for n in range(self.n_ancilla_qubits):
                    with super().if_test(self.cbit_xor([self.curr_syndrome_cregs[q][n], self.prev_syndrome_cregs[q][self.z_stabilizers[n]]])) as _else:
                        self.set_cbit(self.unflagged_syndrome_diff_cregs[q][self.z_stabilizers[n]], 1)
                    with _else:
                        self.set_cbit(self.unflagged_syndrome_diff_cregs[q][self.z_stabilizers[n]], 0)

                # Final correction
                self.apply_decoding([q], self.z_stabilizers, with_flagged=False)
                with super().if_test(expr.lift(self.pauli_frame_cregs[q][1])):
                    self.cbit_not(self.output_creg[c])

    def measure_all(self, with_error_correction=True):
        self.measure(range(self.n_logical_qubits), range(self.n_logical_qubits))

    def get_logical_output_counts(self, outputs, logical_qubit_indices=None):
        if logical_qubit_indices == None:
            logical_qubit_indices = range(self.n_logical_qubits)

        counts = {}
        for n in range(len(outputs)):
            output = ''
            for l in logical_qubit_indices:
                output = outputs[n][self.n_logical_qubits-1-l] + output

            if output not in counts:
                counts[output] = 1
            else:
                counts[output] += 1

        return counts

    ######################################
    ##### Logical quantum operations #####
    ######################################

    # @TODO - generalize logical quantum operations using stabilizers

    def h(self, *targets, method="Coherent_Feedback"):
        """
        Logical Hadamard gate
        """

        if len(targets) == 1 and hasattr(targets[0], "__iter__"):
            targets = targets[0]

        if method == "LCU":
            for t in targets:
                with self.box(label="logical.logicalop.h.lcu:$\\hat H_{L}$"):
                    super().compose(self.LogicalHCircuit_LCU, [self.logical_op_qregs[t][0]] + self.logical_qregs[t][:], inplace=True)

            # @TODO - perform resets after main operation is complete to allow for faster(?) parallel operation
            # for t in targets:
                # @TODO - determine whether extra reset is necessary at the end
                # with self.box(label="logical.logicalop.lcu"):
                    # super().reset(self.logical_op_qregs[t])
        elif method == "LCU_Corrected": 
            for t in targets:
                with self.box(label="logical.logicalop.h.lcu_corrected:$\\hat H_{L}$"):
                    # Construct circuit for implementing a Hadamard gate through the use of an ancilla
                    super().h(self.logical_op_qregs[t][0])
                    super().compose(self.LogicalXCircuit.control(1), [self.logical_op_qregs[t][0]] + self.logical_qregs[t][:], inplace=True)
                    super().compose(self.LogicalZCircuit.control(1), [self.logical_op_qregs[t][0]] + self.logical_qregs[t][:], inplace=True)
                    super().h(self.logical_op_qregs[t][0])
                    super().append(Measure(), [self.logical_op_qregs[t][0]], [self.logical_op_meas_cregs[t][0]], copy=False)
                    super().reset(self.logical_op_qregs[t][0])

                    # Corrections to apply based on ancilla measurement
                    with super().if_test((self.logical_op_meas_cregs[t][0], 1)) as else_:
                        self.x(t)
                    with else_:
                        self.z(t)

        elif method == "Coherent_Feedback":
            for t in targets:
                with self.box(label="logical.logicalop.h.coherent_feedback:$\\hat H_{L}$"):
                    super().compose(self.LogicalHCircuit_CF, self.logical_qregs[t][:] + [self.logical_op_qregs[t][0]], inplace=True)

        elif method == "Transversal_Uniform":
            for t in targets:
                with self.box(label="logical.logicalop.h.transversal_uniform:$\\hat H_{L}$"):
                    super().h(self.logical_qregs[t][:])
        else:
            raise ValueError(f"'{method}' is not a valid method for the logical Hadamard gate")

    def x(self, *targets):
        """
        Logical PauliX gate
        """

        if len(targets) == 1 and hasattr(targets[0], "__iter__"):
            targets = targets[0]

        for t in targets:
            with self.box(label="logical.logicalop.x.gottesman:$\\hat X_{L}$"):
                super().compose(self.LogicalXCircuit, self.logical_qregs[t], inplace=True)

    def y(self, *targets):
        """
        Logical PauliY gate
        """

        if len(targets) == 1 and hasattr(targets[0], "__iter__"):
            targets = targets[0]

        with self.box(label="logical.logicalop.y.derived:$\\hat Y_{L}$"):
            self.z(targets)
            self.x(targets)

    def z(self, *targets):
        """
        Logical PauliZ gate
        """

        if len(targets) == 1 and hasattr(targets[0], "__iter__"):
            targets = targets[0]

        for t in targets:
            with self.box(label="logical.logicalop.z.gottesman:$\\hat Z_{L}$"):
                super().compose(self.LogicalZCircuit, self.logical_qregs[t], inplace=True)

    def s(self, *targets, method="Coherent_Feedback"):
        """
        Logical S gate

        Definition:
        [1   0]
        [0   i]
        """

        if len(targets) == 1 and hasattr(targets[0], "__iter__"):
            targets = targets[0]

        if method == "LCU_Corrected":
            for t in targets:
                with self.box(label="logical.logicalop.s.lcu_corrected:$\\hat S_{L}$"):
                    super().h(self.logical_op_qregs[t][0])
                    super().s(self.logical_op_qregs[t][0])
                    super().h(self.logical_op_qregs[t][0])
                    super().compose(self.LogicalZCircuit.control(1), [self.logical_op_qregs[t][0]] + self.logical_qregs[t][:], inplace=True)
                    super().h(self.logical_op_qregs[t][0])
                    super().append(Measure(), [self.logical_op_qregs[t][0]], [self.logical_op_meas_cregs[t][0]], copy=False)

                    with super().if_test((self.logical_op_meas_cregs[t][0], 1)):
                        self.z(t)

                    super().reset(self.logical_op_qregs[t][0])
        elif method == "Coherent_Feedback":
            for t in targets:
                with self.box(label="logical.logicalop.s.coherent_feedback:$\\hat S_{L}$"):
                    super().compose(self.LogicalSCircuit_CF, self.logical_qregs[t][:] + [self.logical_op_qregs[t][0]], inplace=True)
        elif method == "Transversal_Uniform":
            for t in targets:
                with self.box(label="logical.logicalop.s.transversal_uniform:$\\hat S_{L}$"):
                    super().sdg(self.logical_qregs[t][:])

        else:
            raise ValueError(f"'{method}' is not a valid method for the logical S gate")

    def sdg(self, *targets, method="Coherent_Feedback"):
        """
        Logical S^dagger gate

        Definition:
        [1    0]
        [0   -i]
        """
        
        if len(targets) == 1 and hasattr(targets[0], "__iter__"):
            targets = targets[0]

        if method == "LCU_Corrected":
            for t in targets:
                with self.box(label="logical.logicalop.sdg.lcu_corrected:$\\hat{S^\\dagger}_{L}$"):
                    super().h(self.logical_op_qregs[t][0])
                    super().sdg(self.logical_op_qregs[t][0])
                    super().h(self.logical_op_qregs[t][0])
                    super().compose(self.LogicalZCircuit.control(1), [self.logical_op_qregs[t][0]] + self.logical_qregs[t][:], inplace=True)
                    super().h(self.logical_op_qregs[t][0])
                    super().append(Measure(), [self.logical_op_qregs[t][0]], [self.logical_op_meas_cregs[t][0]], copy=False)

                    with super().if_test((self.logical_op_meas_cregs[t][0], 1)):
                        self.z(t)

                    super().reset(self.logical_op_qregs[t][0])
        elif method == "Coherent_Feedback":
            for t in targets:
                with self.box(label="logical.logicalop.sdg.coherent_feedback:$\\hat{S^\\dagger}_{L}$"):
                    super().compose(self.LogicalSdgCircuit_CF, self.logical_qregs[t][:] + [self.logical_op_qregs[t][0]], inplace=True)

        elif method == "Transversal_Uniform":
            for t in targets:
                with self.box(label="logical.logicalop.sdg.transversal_uniform:$\\hat{S^\\dagger}_{L}$"):
                    super().s(self.logical_qregs[t][:])

        else:
            raise ValueError(f"'{method}' is not a valid method for the logical S^dagger gate")

    def t(self, *targets, method="Coherent_Feedback"):
        """
        Logical T gate

        Definition:
        [1    0        ]
        [0    e^(ipi/4)]
        """

        if len(targets) == 1 and hasattr(targets[0], "__iter__"):
            targets = targets[0]

        if method == "LCU_Corrected":
            for t in targets:
                with self.box(label="logical.logicalop.t.lcu_corrected:$\\hat T_{L}$"):
                    super().h(self.logical_op_qregs[t][0])
                    super().t(self.logical_op_qregs[t][0])
                    super().h(self.logical_op_qregs[t][0])
                    super().compose(self.LogicalZCircuit.control(1), [self.logical_op_qregs[t][0]] + self.logical_qregs[t][:], inplace=True)
                    super().h(self.logical_op_qregs[t][0])

                    super().append(Measure(), [self.logical_op_qregs[t][0]], [self.logical_op_meas_cregs[t][0]], copy=False)
                    super().reset(self.logical_op_qregs[t][0])

                    with super().if_test((self.logical_op_meas_cregs[t][0], 1)):
                        self.s(t, method='LCU_corrected')

        elif method == "Coherent_Feedback":
            for t in targets:
                with self.box(label="logical.logicalop.t.coherent_feedback:$\\hat T_{L}$"):
                    super().compose(self.LogicalTCircuit_CF, self.logical_qregs[t][:] + self.logical_op_qregs[t][:], inplace=True)

        else:
            raise ValueError(f"'{method}' is not a valid method for the logical T gate")

    def tdg(self, *targets, method="Coherent_Feedback"):
            """
            Logical T^dagger gate

            Definition:
            [1    0         ]
            [0    e^(-ipi/4)]
            """

            if len(targets) == 1 and hasattr(targets[0], "__iter__"):
                targets = targets[0]

            if method == "LCU_Corrected":
                for t in targets:
                    with self.box(label="logical.logicalop.t.lcu_corrected:$\\hat{T^\\dagger}_{L}$"):
                        super().h(self.logical_op_qregs[t][0])
                        super().tdg(self.logical_op_qregs[t][0])
                        super().h(self.logical_op_qregs[t][0])
                        super().compose(self.LogicalZCircuit.control(1), [self.logical_op_qregs[t][0]] + self.logical_qregs[t][:], inplace=True)
                        super().h(self.logical_op_qregs[t][0])

                        super().append(Measure(), [self.logical_op_qregs[t][0]], [self.logical_op_meas_cregs[t][0]], copy=False)
                        super().reset(self.logical_op_qregs[t][0])

                        with super().if_test((self.logical_op_meas_cregs[t][0], 1)):
                            self.sdg(t, method='LCU_corrected')

            elif method == "Coherent_Feedback":
                for t in targets:
                    with self.box(label="logical.logicalop.t.coherent_feedback:$\\hat{T^\\dagger}_{L}$"):
                        super().compose(self.LogicalTdgCircuit_CF, self.logical_qregs[t][:] + self.logical_op_qregs[t][:], inplace=True)

            else:
                raise ValueError(f"'{method}' is not a valid method for the logical T^dagger gate")

    def cx(self, control, *_targets, method="Ancilla_Assisted"):
        """
        Logical Controlled-PauliX gate
        """

        if hasattr(_targets, "__iter__"):
            targets = _targets
        else:
            targets = [_targets]

        # @TODO - implement a better, more generalized CNOT gate
        if method == "Ancilla_Assisted":
            for t in targets:
                with self.box(label="logical.logicalop.cx.ancilla_assisted:$\\hat{CX}_{L}$"):
                    super().h(self.logical_op_qregs[t][0])
                    super().compose(self.LogicalZCircuit.control(1), [self.logical_op_qregs[t][0]] + self.logical_qregs[control][:], inplace=True)
                    super().h(self.logical_op_qregs[t][0])
                    super().compose(self.LogicalXCircuit.control(1), [self.logical_op_qregs[t][0]] + self.logical_qregs[t][:], inplace=True)
                    super().h(self.logical_op_qregs[t][0])
                    super().compose(self.LogicalZCircuit.control(1), [self.logical_op_qregs[t][0]] + self.logical_qregs[control][:], inplace=True)
                    super().h(self.logical_op_qregs[t][0])
        elif method == "Transversal_Uniform":
            for t in targets:
                with self.box(label="logical.logicalop.cx.transversal_uniform:$\\hat{CX}_{L}$"):
                    super().cx(self.logical_qregs[control][:], self.logical_qregs[t][:])
        else:
            raise ValueError(f"'{method}' is not a valid method for the logical CX gate")

    def cz(self, control, *_targets, method="Ancilla_Assisted"):
        """
        Logical Controlled-PauliZ gate
        """

        if hasattr(_targets, "__iter__"):
            targets = _targets
        else:
            targets = [_targets]

        # @TODO - implement a better, more generalized CNOT gate
        if method == "Ancilla_Assisted":
            for t in targets:
                with self.box(label="logical.logicalop.cx.ancilla_assisted:$\\hat{CZ}_{L}$"):
                    super().h(self.logical_op_qregs[t][0])
                    super().compose(self.LogicalZCircuit.control(1), [self.logical_op_qregs[t][0]] + self.logical_qregs[control][:], inplace=True)
                    super().h(self.logical_op_qregs[t][0])
                    super().compose(self.LogicalZCircuit.control(1), [self.logical_op_qregs[t][0]] + self.logical_qregs[t][:], inplace=True)
                    super().h(self.logical_op_qregs[t][0])
                    super().compose(self.LogicalZCircuit.control(1), [self.logical_op_qregs[t][0]] + self.logical_qregs[control][:], inplace=True)
                    super().h(self.logical_op_qregs[t][0])
        elif method == "Transversal_Uniform":
            for t in targets:
                with self.box(label="logical.logicalop.cx.transversal_uniform:$\\hat{CZ}_{L}$"):
                    super().cz(self.logical_qregs[control][:], self.logical_qregs[t][:])
        else:
            raise ValueError(f"'{method}' is not a valid method for the logical CZ gate")
        
    def cy(self, control, *_targets, method="Ancilla_Assisted"):
        """
        Logical Controlled-PauliY gate
        """

        if hasattr(_targets, "__iter__"):
            targets = _targets
        else:
            targets = [_targets]

        # @TODO - implement a better, more generalized CNOT gate
        if method == "Ancilla_Assisted":
            for t in targets:
                with self.box(label="logical.logicalop.cx.ancilla_assisted:$\\hat{CY}_{L}$"):
                    self.sdg(t)
                    super().h(self.logical_op_qregs[t][0])
                    super().compose(self.LogicalZCircuit.control(1), [self.logical_op_qregs[t][0]] + self.logical_qregs[control][:], inplace=True)
                    super().h(self.logical_op_qregs[t][0])
                    super().compose(self.LogicalXCircuit.control(1), [self.logical_op_qregs[t][0]] + self.logical_qregs[t][:], inplace=True)
                    super().h(self.logical_op_qregs[t][0])
                    super().compose(self.LogicalZCircuit.control(1), [self.logical_op_qregs[t][0]] + self.logical_qregs[control][:], inplace=True)
                    super().h(self.logical_op_qregs[t][0])
                    self.s(t)
        elif method == "Transversal_Uniform":
            for t in targets:
                with self.box(label="logical.logicalop.cx.transversal_uniform:$\\hat{CY}_{L}$"):
                    super().cx(self.logical_qregs[control][:], self.logical_qregs[t][:])
        else:
            raise ValueError(f"'{method}' is not a valid method for the logical CY gate")

    def mcmt(self, gate, controls, targets):
        """
        Logical Multi-Control Multi-Target gate
        """

        if len(controls) == 1 and hasattr(controls[0], "__iter__"):
            controls = controls[0]

        if len(targets) == 1 and hasattr(targets[0], "__iter__"):
            targets = targets[0]

        control_qubits = [self.logical_qregs[c][:] for c in controls]
        target_qubits = [self.logical_qregs[t][:] for t in targets]

        if not set(control_qubits).isdisjoint(target_qubits):
            raise ValueError("Qubit(s) specified as both control and target")

        with self.box(label="logical.logicalop.mcmt.default:$\\hat{MCMT}_{L}$"):
            super().append(gate.control(len(controls)), control_qubits + target_qubits)

    # Input could be: 1. (CircuitInstruction(name="...", qargs="...", cargs="..."), qargs=None, cargs=None)
    #                 2. (Instruction(name="..."), qargs=[..], cargs=[...])
    def append(self, instruction, qargs=None, cargs=None, copy=True):
        if isinstance(instruction, str):
            operation = instruction
        elif hasattr(instruction, "name"):
            operation = instruction.name.lower()
        else:
            raise ValueError(f"Instruction could not be parsed: {instruction}")

        # @TODO - copy.deepcopy fails for some instructions (such as IfElseOp), figure out a fix
        if copy and not isinstance(instruction, bool):
            try:
                instruction = copy.deepcopy(instruction)
            except:
                pass
                # print(f"WARNING: LogicalCircuit does not support append-by-copy for instruction '{operation}', ignoring")

        if qargs is None:
            if hasattr(instruction, "qubits"):
                qargs = instruction.qubits
                qubits = [qubit._index for qubit in instruction.qubits]
        else:
            if all([isinstance(qarg, int) for qarg in qargs]):
                qubits = qargs
            elif all([isinstance(qarg, Bit) for qarg in qargs]):
                qubits = [qarg._index for qarg in qargs]
            elif hasattr(instruction, "qubits"):
                qubits = [qubit._index for qubit in instruction.qubits]
            elif all([isinstance(qarg, QuantumRegister) for qarg in qargs]):
                qubits = [qubit._index for qarg in qargs for qubit in qarg]
            else:
                raise ValueError(f"At least one of the following quantum arguments to operation '{operation}' are unrecognized: {qargs}")

        if cargs is None:
            if hasattr(instruction, "clbits"):
                cargs = instruction.clbits
                clbits = [clbit._index for clbit in instruction.clbits]
        else:
            if all([isinstance(carg, int) for carg in cargs]):
                clbits = cargs
            elif all([isinstance(carg, Bit) for carg in cargs]):
                qubits = [carg._index for carg in cargs]
            elif hasattr(instruction, "clbits"):
                clbits = [clbit._index for clbit in instruction.clbits]
            elif all([isinstance(carg, ClassicalRegister) for carg in cargs]):
                clbits = [clbit._index for carg in cargs for clbit in carg]
            else:
                raise ValueError(f"At least one of the following classical arguments to operation '{operation}' are unrecognized: {cargs}")

        match operation:
            case "h":
                self.h(qubits)
            case "x":
                self.x(qubits)
            case "y":
                self.y(qubits)
            case "z":
                self.z(qubits)
            case "s":
                self.s(qubits)
            case "sdg":
                self.sdg(qubits)
            case "t":
                self.t(qubits)
            case "tdg":
                self.tdg(qubits)
            case "cx":
                control_qubit = instruction.qubits[0]._index
                target_qubit = instruction.qubits[1]._index
                self.cx(control_qubit, target_qubit)
            case "cz":
                control_qubit = instruction.qubits[0]._index
                target_qubit = instruction.qubits[1]._index
                self.cz(control_qubit, target_qubit)
            case "cy":
                control_qubit = instruction.qubits[0]._index
                target_qubit = instruction.qubits[1]._index
                self.cy(control_qubit, target_qubit)
            case "mcmt":
                raise NotImplementedError(f"Physical operation 'MCMT' does not have physical gate conversion implemented!")
            case "measure":
                # If classical bits for measurement aren't specified, default to match logical qubit indices
                if clbits is None:
                    clbits = qubits

                # @TODO - decide best default behavior here (maybe we should ask during from_physical_circuit)
                self.measure(qubits, clbits, with_error_correction=True)
            case "barrier":
                pass
            case _:
                # @TODO - identify a better way of providing these warnings
                # print(f"WARNING: Physical operation '{operation.upper()}' does not have a logical counterpart implemented! Defaulting to physical operation.")

                instruction = super().append(instruction, qargs, cargs, copy=copy)

        return instruction

    ###########################
    ##### Utility methods #####
    ###########################

    # Adds a desired error for testing
    def add_error(self, l_ind, p_ind, error_type):
        if error_type == 'X':
            super().x(self.logical_qregs[l_ind][p_ind])
        if error_type == 'Z':
            super().z(self.logical_qregs[l_ind][p_ind])

    # @TODO - find alternative to classical methods, possibly by implementing upstream

    # Set values of classical bits
    def set_cbit(self, cbit, value):
        if value == 0:
            # super().measure(self.cbit_setter_qreg[0], cbit)
            super().append(Measure(), [self.cbit_setter_qreg[0]], [cbit], copy=False)
        else:
            # super().measure(self.cbit_setter_qreg[1], cbit)
            super().append(Measure(), [self.cbit_setter_qreg[1]], [cbit], copy=False)

    # Performs a NOT statement on a classical bit
    def cbit_not(self, cbit):
        with self.if_test(expr.lift(cbit)) as _else:
            self.set_cbit(cbit, 0)
        with _else:
            self.set_cbit(cbit, 1)

    # Performs AND and NOT statements on multiple classical bits, e.g. (~c[0] & ~c[1] & c[2])
    def cbit_and(self, cbits, values):
        result = expr.bit_not(cbits[0]) if values[0] == 0 else expr.lift(cbits[0])
        for n in range(len(cbits)-1):
            result = expr.bit_and(result, expr.bit_not(cbits[n+1])) if values[n+1] == 0 else expr.bit_and(result, cbits[n+1])
        return result

    # XOR multiple classical bits
    def cbit_xor(self, cbits):
        result = expr.lift(cbits[0])
        for n in range(len(cbits)-1):
            result = expr.bit_xor(result, cbits[n+1])
        return result

    ######################################
    ##### Visualization and analysis #####
    ######################################

    def draw(
        self,
        output=None,
        scale=None,
        filename=None,
        style=None,
        interactive=False,
        plot_barriers=True,
        reverse_bits=None,
        justify=None,
        vertical_compression="medium",
        idle_wires=None,
        with_layout=True,
        fold=None,
        # The type of ax is matplotlib.axes.Axes, but this is not a fixed dependency, so cannot be
        # safely forward-referenced.
        ax=None,
        initial_state=False,
        cregbundle=None,
        wire_order=None,
        expr_len=30,
        fold_qec=True,
        fold_logicalop=True,
    ):
        """
        LogicalCircuit drawer based on Qiskit circuit drawer
        """

        from .Visualization.LogicalCircuitVisualization import logical_circuit_drawer

        return logical_circuit_drawer(
            self,
            scale=scale,
            filename=filename,
            style=style,
            output=output,
            interactive=interactive,
            plot_barriers=plot_barriers,
            reverse_bits=reverse_bits,
            justify=justify,
            vertical_compression=vertical_compression,
            idle_wires=idle_wires,
            with_layout=with_layout,
            fold=fold,
            ax=ax,
            initial_state=initial_state,
            cregbundle=cregbundle,
            wire_order=wire_order,
            expr_len=expr_len,
            fold_qec=fold_qec,
            fold_logicalop=fold_logicalop,
        )

class LogicalStatevector(Statevector):
    def __init__(self, data, dims=None):
        super().__init__(data=data, dims=dims)

        raise NotImplementedError("LogicalStatevector has not been fully implemented yet!")

class LogicalDensityMatrix(DensityMatrix):
    def __init__(self, data, dims=None):
        super().__init__(data=data, dims=dims)

        raise NotImplementedError("LogicalDensityMatrix has not been fully implemented yet!")

