import sys

from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit

class LogicalCircuit(QuantumCircuit):
    def __init__(
            self,
            n_logical_qubits,
            stabilizer_tableau = None,
            name: str | None = None,
        ):

        self.n_logical_qubits = n_logical_qubits

        if stabilizer_tableau == None:
            raise ValueError("No stabilizer tableau provided!")
        
        self.n_stabilizers = len(stabilizer_tableau)
        self.n_physical_qubits = len(stabilizer_tableau[0])
        self.n_ancilla_qubits = self.n_stabilizers//2
        self.n_measure_qubits = self.n_ancilla_qubits

        self.logical_qregs, self.ancilla_qregs, self.measure_cregs, self.enc_verif_cregs, self.prev_syndrome_cregs, self.curr_syndrome_cregs, self.flagged_syndrome_diff_cregs, self.unflagged_syndrome_diff_cregs = []

        # The full circuit is generated by calling super()
        super().__init__(name=name)

        # @TODO - find alternative, possibly by implementing upstream
        # Create setter qreg for purpose of setting classical bits dynamically
        self.setter_qreg = QuantumRegister(2, name="qsetter")
        self.x(self.setter_qreg[1])
        self.measure(self.setter_qreg[1], self.enc_verif_cregs[0])

    def add_logical_qubits(self, logical_qubit_count):
        current_logical_qubit_count = len(self.logical_qregs)

        for i in range(current_logical_qubit_count, current_logical_qubit_count + logical_qubit_count):
            # Physical qubits for logical qubit
            logical_qreg_i = QuantumRegister(self.n_logical_qubits, name=f"qlog{i}")
            # Ancilla qubits needed for measurements
            ancilla_qreg_i = AncillaRegister(self.n_ancilla_qubits, name=f"qanc{i}")
            # Classical bits needed for measurements
            measure_creg_i = ClassicalRegister(self.n_measure_qubits, name=f"cmeas{i}")
            # Classical bits needed for encoding verification
            enc_verif_creg_i = ClassicalRegister(self.n_measure_qubits, name=f"cenc_verif{i}")
            # Classical bits needed for previous syndrome measurements
            prev_syndrome_creg_i = ClassicalRegister(self.n_stabilizers//2, name=f"cprev_syndrome{i}")
            # Classical bits needed for current syndrome measurements
            curr_syndrome_creg_i = ClassicalRegister(self.n_stabilizers//2, name=f"ccurr_syndrome{i}")
            # Classical bits needed for flagged syndrome difference measurements
            flagged_syndrome_diff_creg_i = ClassicalRegister(self.n_stabilizers//2, name=f"cflagged_syndrome_diff{i}")
            # Classical bits needed for unflagged syndrome difference measurements
            unflagged_syndrome_diff_creg_i = ClassicalRegister(self.n_stabilizers//2, name=f"cunflagged_syndrome_diff{i}")

            # Add new registers to storage lists
            self.logical_qregs.append(logical_qreg_i)
            self.ancilla_qregs.append(ancilla_qreg_i)
            self.measure_cregs.append(measure_creg_i)
            self.enc_verif_cregs.append(enc_verif_creg_i)
            self.prev_syndrome_cregs.append(prev_syndrome_creg_i)
            self.curr_syndrome_cregs.append(curr_syndrome_creg_i)
            self.flagged_syndrome_diff_cregs.append(flagged_syndrome_diff_creg_i)
            self.unflagged_syndrome_diff_cregs.append(unflagged_syndrome_diff_creg_i)

            # Add new registers to quantum circuit
            super().add_register(logical_qreg_i)
            super().add_register(ancilla_qreg_i)
            super().add_register(measure_creg_i)
            super().add_register(enc_verif_creg_i)
            super().add_register(prev_syndrome_creg_i)
            super().add_register(curr_syndrome_creg_i)
            super().add_register(flagged_syndrome_diff_creg_i)
            super().add_register(unflagged_syndrome_diff_creg_i)

    ############################################
    ##### Quantum error correction methods #####
    ############################################

    # @TODO - verify correctness of modifications to demo
    def encode(self, *qubits, max_iterations=1, initial_states=[]):
        """
        Prepare logical qubit(s) in the specified initial state
        """
        
        if len(initial_states) > 0 and len(qubits) != len(initial_states):
            raise ValueError("Number of qubits should equal number of initial states if initial states are provided")

        for q in qubits:
            # Preliminary physical qubit reset
            super().reset(self.logical_qregs[q])
            
            # Initial encoding
            super().append(encode_gate(), self.logical_qregs[q][:7])

            # CNOT from (Z1 Z3 Z5) to ancilla
            super().cx(self.logical_qregs[q][1], self.ancilla_qregs[q][0])
            super().cx(self.logical_qregs[q][3], self.ancilla_qregs[q][0])
            super().cx(self.logical_qregs[q][5], self.ancilla_qregs[q][0])

            # Measure ancilla
            super().measure(self.ancilla_qregs[q][0], self.enc_verif_cregs[q][0])

            for _ in range(max_iterations - 1):
                # If the ancilla stores a 1, reset the entire logical qubit and redo
                with super().if_test((self.enc_verif_cregs[q][0], 1)):
                    super().reset(self.logical_qregs[q])

                    # Initial encoding
                    super().append(encode_gate(), self.logical_qregs[q])

                    # CNOT from (Z1 Z3 Z5) to ancilla
                    super().cx(self.logical_qregs[q][1], self.ancilla_qregs[q][0])
                    super().cx(self.logical_qregs[q][3], self.ancilla_qregs[q][0])
                    super().cx(self.logical_qregs[q][5], self.ancilla_qregs[q][0])

                    # Measure ancilla
                    super().measure(self.ancilla_qregs[q][0], self.enc_verif_cregs[q][0])
        
        # Reset ancilla qubit
        super().reset(self.ancila_qregs[q][0])

        # Flip qubits if necessary
        for initial_state in initial_states:
            if initial_state == 1:
                super().x(self.logical_qregs[q][:7])
            elif initial_state != 0:
                raise ValueError("Initial state should be either 0 or 1 (arbitrary statevectors not yet supported)!")
        
        return True

    # @TODO - verify correctness of modifications to demo
    # Measure flagged or unflagged syndrome differences for specified logical qubits and stabilizers
    def measure_syndrome_diff(self, logical_qubit_indices=[], stabilizer_indices=[], flagged=False):
        if len(logical_qubit_indices) == 0:
            logical_qubit_indices = list(range(self.n_logical_qubits))
        
        if len(stabilizer_indices) == 0:
            stabilizer_indices = list(range(self.n_stabilizers))
        
        for q in logical_qubit_indices:
            syndrome_diff_creg = self.flagged_syndrome_diff_cregs[q] if flagged else self.unflagged_syndrome_diff_cregs[q]
            
            # Apply and measure stabilizers for the desired syndrome
            self.add_stabilizers(stabilizer_indices)
            for n in range(self.num_ancillas):
                self.measure(self.ancillas[n], self.curr_syndrome_cregs[q][n])
        
            # Determine the syndrome difference
            for s in range(len(stabilizer_indices)):
                with self.if_test(expr.bit_xor(self.curr_syndrome_cregs[q][n], self.prev_syndrome_cregs[q][stabilizer_indices[n]-1])) as _else:
                    self.set_cbit(syndrome_diff_creg, stabilizer_indices[n]-1, 1)
                with _else:
                    self.set_cbit(syndrome_diff_creg, stabilizer_indices[n]-1, 0)
        
        self.barrier()
        self.reset_ancillas(logical_qubit_indices)
        self.barrier()

    # @TODO - verify correctness of modifications to demo
    # Reset all ancillas associated with specified logical qubits
    def reset_ancillas(self, logical_qubit_indices=[]):
        if len(logical_qubit_indices) == 0:
            logical_qubit_indices = list(range(self.n_logical_qubits))
        
        for q in logical_qubit_indices:
            self.reset(self.ancilla_qregs[q])

    # @TODO - verify correctness of modifications to demo
    # Add specified specifiers to the circuit as controlled Pauli operators
    def add_stabilizers(self, stabilizer_indices=[]):
        if len(stabilizer_indices) == 0:
            stabilizer_indices = list(range(self.n_stabilizers))
        
        for s in stabilizer_indices:
            stabilizer = self.stabilizers[s]

            for p, pauli_character in enumerate(stabilizer):
                CPauliInstruction = Pauli(pauli_character).to_instruction().control(1)
                self.append(CPauliInstruction, self.logical_qregs[q][p], self.ancilla_qregs[q][s])
            
            circuit.barrier()

    # @TODO - allow configuration of QEC cycling
    def configure_qec_cycle(self, sample_rate):
        raise NotImplementedError("QEC Cycle configuration has not yet been implemented.")

    # @TODO - verify correctness of modifications to demo
    # @TODO - adapt demo code to LogicalCircuit class structure
    def perform_qec_cycle(self, logical_qubit_indices=[]):
        if len(logical_qubit_indices) == 0:
            logical_qubit_indices = list(range(self.n_logical_qubits))

        # @TODO - determine how stabilizers are selected for flagged measurements

        for q in logical_qubit_indices:
            super().reset(self.ancilla_qregs[q])

            # Perform first flagged syndrome measurements
            self.measure_syndrome_diff(fs1, flagged=True)
        
            # If no change in syndrome, perform second flagged syndrome measurement
            with self.if_test(expr.equal(self.flagged_syndrome_diff_cregs[q], 0)):
                self.measure_syndrome_diff(fs2, flagged=True)
        
            # If change in syndrome, perform unflagged syndrome measurement, decode, and correct
            with self.if_test(expr.not_equal(self.flagged_syndrome_diff_cregs[q], 0)):
                self.measure_syndrome_diff(sx, flagged=False)
                self.measure_syndrome_diff(sz, flagged=False)
        
                self.apply_decoding(sx, with_flagged=False)
                self.apply_decoding(sz, with_flagged=False)
                self.apply_decoding(sx, with_flagged=True)
                self.apply_decoding(sz, with_flagged=True)
        
                # Update previous syndrome
                for n in range(len(syn_diff)):
                    with self.if_test(expr.lift(self.unflagged_syndrome_diff_cregs[q][n])):
                        self.flip_cbit("prev_syn", cregs, n)

    def apply_decoding(self, *):
        raise NotImplementedError("Decoding has not yet been implemented")

    def mesaure_syndrome_diff(self, *):
        raise NotImplementedError("Decoding has not yet been implemented")

    # @TODO - adapt to LogicalCircuit class structure
    # Set values of classical bits
    def set_cbit(self, creg, cbit_index, value):
        if value == 0:
            self.measure(self.cbit_setter_qreg[2][0], creg[cbit_index])
        else:
            self.measure(self.cbit_setter_qreg[2][1], creg[cbit_index])

    # @TODO - adapt to LogicalCircuit class structure
    # Performs NOT statements multiple classical bits
    def cbit_not(self, creg, cregs, ind):
        with circuit.if_test(expr.lift(circuit.cregs[cregs[creg]][ind])) as _else:
            set_cbit(circuit, creg, cregs, ind, 0)
        with _else:
            set_cbit(circuit, creg, cregs, ind, 1)
    
    # Performs AND and NOT statements on multiple classical bits, e.g. (~c[0] & ~c[1] & c[2])
    def cbit_and(self, cbits, values):
        result = expr.bit_not(cbits[0]) if values[0] == 0 else expr.lift(cbits[0])
        for n in range(len(cbits)-1):
            result = expr.bit_and(result, expr.bit_not(cbits[n+1])) if values[n+1] == 0 else expr.bit_and(result, cbits[n+1])
        return result
    
    # XOR multiple classical bits
    def cbit_xor(self, creg, cbits):
        result = expr.lift(creg[cbits[0]])
        for n in range(len(cbits)-1):
            result = expr.bit_xor(result, creg[cbits[n+1]])
        return result

    ######################################
    ##### Logical Quantum Operations #####
    ######################################

    def h(self, *targets):
        """
        Logical Hadamard operation
        """

        for t in targets:
            super().h(self.logical_qregs[t][4:7])
    
    def x(self, *targets):
        """
        Logical PauliX operation
        """

        for t in targets:
            super().x(self.logical_qregs[t][4:7])
    
    def y(self, *targets):
        """
        Logical PauliY operation
        """

        for t in targets:
            super().y(self.logical_qregs[t][4:7])
    
    def z(self, *targets):
        """
        Logical PauliZ operation
        """

        for t in targets:
            super().z(self.logical_qregs[t][4:7])
    
    def s(self, *targets):
        """
        Logical phase gate operation
        """

        for t in targets:
            super().s(self.logical_qregs[t][4:7])
            super().s(self.logical_qregs[t][4:7])
            super().s(self.logical_qregs[t][4:7])
    
    def cx(self, control, *targets):
        """
        Logical Controlled-PauliX operation
        """

        for t in targets:
            super().cx(self.logical_qregs[control], self.logical_qregs[t][4:7])

