from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit

import sys, importlib
# importlib.reload(sys.modules['steane_code'])
from steane_code import encode_gate

class LogicalCircuit(QuantumCircuit):
    def __init__(
            self,
            n_logical_qubits,
            name: str | None = None,
        ):

        # @TODO - Allow for code generation from stabilizer tableau

        self.n = 7

        # Each quantum register stores a single logical qubit plus an ancilla for state prep
        self.logical_qregs = [QuantumRegister(self.n + 1, name=f"q{i}") for i in range(n_logical_qubits)]
        # Each classical register stores the three classical bits needed for syndrome measurement
        self.meas_cregs = [ClassicalRegister(3, name=f"c{i}") for i in range(n_logical_qubits)]

        # The full circuit is generated by calling super()
        super().__init__(*self.logical_qregs, *self.meas_cregs, name=name)

    def add_logical_qubits(self, qubit_count):
        current_qubit_count = len(self.logical_qregs)

        for i in range(current_qubit_count, current_qubit_count + qubit_count):
            qreg_i = QuantumRegister(self.n + 1, name=f"q{i}")
            creg_i = ClassicalRegister(3, name=f"c{i}")

            self.logical_qregs.append(qreg_i)
            self.meas_cregs.append(creg_i)

            super().add_register(qreg_i)
            super().add_register(creg_i)

    def encode(self, *qubits, max_iterations=1, initial_states=[]):
        """
        Prepare logical qubit(s) in the specified initial state
        """

        for q in qubits:
            # Initial encoding
            super().append(encode_gate(), self.logical_qregs[q][:7])

            # CNOT from (Z1 Z3 Z5) to ancilla
            super().cx(self.logical_qregs[q][1], self.logical_qregs[q][7])
            super().cx(self.logical_qregs[q][3], self.logical_qregs[q][7])
            super().cx(self.logical_qregs[q][5], self.logical_qregs[q][7])

            # Measure ancilla
            super().measure(7,0)

            i = 1
            while i < max_iterations:
                # If the ancilla stores a 1, reset the entire logical qubit and redo
                with super().if_test((self.meas_cregs[q], 1)):
                    super().reset(self.logical_qregs[q])

                    # Initial encoding
                    super().append(encode_gate(), self.logical_qregs[q][:7])

                    # CNOT from (Z1 Z3 Z5) to ancilla
                    super().cx(self.logical_qregs[q][1], self.logical_qregs[q][7])
                    super().cx(self.logical_qregs[q][3], self.logical_qregs[q][7])
                    super().cx(self.logical_qregs[q][5], self.logical_qregs[q][7])

                    # Measure ancilla
                    super().measure(7,0)
                
                i += 1
        
        # Reset ancilla qubit
        super().reset(self.logical_qregs[q][7])

        # Flip qubits if necessary
        for initial_state in initial_states:
            if initial_state == 1:
                super().x(self.logical_qregs[q][:7])
        
        return True

    def x(self, *targets):
        """
        Logical PauliX operation
        """

        for t in targets:
            super().x(self.logical_qregs[t][4:7])
    
    def cx(self, control, *targets):
        """
        Logical Controlled-PauliX operation
        """

        for t in targets:
            super().cx(self.logical_qregs[control], self.logical_qregs[t][4:7])

    def measure_syndrome():
        # @TODO - Measure syndromes
        pass
