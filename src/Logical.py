from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit

import sys, importlib
# importlib.reload(sys.modules['steane_code'])
from steane_code import encode_gate

class LogicalCircuit(QuantumCircuit):
    def __init__(
            self,
            n_logical_qubits,
            stabilizer_tableau = None,
            name: str | None = None,
        ):

        # @TODO - Allow for code generation from stabilizer tableau
        if stabilizer_tableau:
            self.n = len(stabilizer_tableau[0])
            n_ancilla_qubits = len(stabilizer_tableau)
        else:
            # Default: Steane Code
            self.n = 7

        # Each logical quantum register stores a single logical qubit
        self.logical_qregs = [QuantumRegister(self.n, name=f"qlog{i}") for i in range(n_logical_qubits)]
        # Each ancilla quantum register stores the three quantum bits needed for measurements
        self.ancilla_qregs = [QuantumRegister(3, name=f"qanc{i}") for i in range(n_logical_qubits)]
        # Each measurement classical register stores the three classical bits needed for measurements
        self.measure_cregs = [ClassicalRegister(3, name=f"cmeas{i}") for i in range(n_logical_qubits)]

        # The full circuit is generated by calling super()
        super().__init__(*self.logical_qregs, *self.ancilla_qregs, *self.measure_cregs, name=name)

    def add_logical_qubits(self, qubit_count):
        current_qubit_count = len(self.logical_qregs)

        for i in range(current_qubit_count, current_qubit_count + qubit_count):
            logical_qreg_i = QuantumRegister(self.n, name=f"qlog{i}")
            ancilla_qreg_i = QuantumRegister(3, name=f"qanc{i}")
            measure_creg_i = ClassicalRegister(3, name=f"cmeas{i}")

            self.logical_qregs.append(logical_qreg_i)
            self.ancilla_qregs.append(ancilla_qreg_i)
            self.measure_cregs.append(measure_creg_i)

            super().add_register(logical_qreg_i)
            super().add_register(ancilla_qreg_i)
            super().add_register(ancilla_qreg_i)

    def encode(self, *qubits, max_iterations=1, initial_states=[]):
        """
        Prepare logical qubit(s) in the specified initial state
        """

        for q in qubits:
            # Initial encoding
            super().append(encode_gate(), self.logical_qregs[q][:7])

            # CNOT from (Z1 Z3 Z5) to ancilla
            super().cx(self.logical_qregs[q][1], self.ancilla_qregs[q][0])
            super().cx(self.logical_qregs[q][3], self.ancilla_qregs[q][0])
            super().cx(self.logical_qregs[q][5], self.ancilla_qregs[q][0])

            # Measure ancilla
            super().measure(self.ancilla_qregs[q][0], self.measure_cregs[q][0])

            for _ in range(max_iterations - 1):
                # If the ancilla stores a 1, reset the entire logical qubit and redo
                with super().if_test((self.measure_cregs[q][0], 1)):
                    super().reset(self.logical_qregs[q])

                    # Initial encoding
                    super().append(encode_gate(), self.logical_qregs[q])

                    # CNOT from (Z1 Z3 Z5) to ancilla
                    super().cx(self.logical_qregs[q][1], self.ancilla_qregs[q][0])
                    super().cx(self.logical_qregs[q][3], self.ancilla_qregs[q][0])
                    super().cx(self.logical_qregs[q][5], self.ancilla_qregs[q][0])

                    # Measure ancilla
                    super().measure(self.ancilla_qregs[q][0], self.measure_cregs[q][0])
        
        # Reset ancilla qubit
        super().reset(self.logical_qregs[q][:7])

        # Flip qubits if necessary
        for initial_state in initial_states:
            if initial_state == 1:
                super().x(self.logical_qregs[q][:7])
        
        return True
    
    def h(self, *targets):
        """
        Logical Hadamard operation
        """

        for t in targets:
            super().h(self.logical_qregs[t][4:7])
    
    def x(self, *targets):
        """
        Logical PauliX operation
        """

        for t in targets:
            super().x(self.logical_qregs[t][4:7])
    
    def y(self, *targets):
        """
        Logical PauliY operation
        """

        for t in targets:
            super().y(self.logical_qregs[t][4:7])
    
    def z(self, *targets):
        """
        Logical PauliZ operation
        """

        for t in targets:
            super().z(self.logical_qregs[t][4:7])
    
    def s(self, *targets):
        """
        Logical phase gate operation
        """

        for t in targets:
            super().s(self.logical_qregs[t][4:7])
            super().s(self.logical_qregs[t][4:7])
            super().s(self.logical_qregs[t][4:7])
    
    def cx(self, control, *targets):
        """
        Logical Controlled-PauliX operation
        """

        for t in targets:
            super().cx(self.logical_qregs[control], self.logical_qregs[t][4:7])

    def measure_syndrome(self):
        # @TODO - Measure syndromes
        pass

    def syndrome_flagged_first(self):
        logical_qreg = QuantumRegister(self.n_qubits)
        ancilla_qreg = QuantumRegister(3)

        qcirc = QuantumCircuit(logical_qreg, ancilla_qreg)

        qcirc.h(logical_qreg[7])

        qcirc.cx(logical_qreg[7], logical_qreg[3])
        qcirc.cx(logical_qreg[2], logical_qreg[9])
        qcirc.cx(logical_qreg[5], logical_qreg[8])
        qcirc.cx(logical_qreg[7], logical_qreg[8])
        qcirc.cx(logical_qreg[7], logical_qreg[0])
        qcirc.cx(logical_qreg[3], logical_qreg[9])
        qcirc.cx(logical_qreg[4], logical_qreg[8])
        qcirc.cx(logical_qreg[7], logical_qreg[1])
        qcirc.cx(logical_qreg[6], logical_qreg[9])
        qcirc.cx(logical_qreg[2], logical_qreg[8])
        qcirc.cx(logical_qreg[7], logical_qreg[9])
        qcirc.cx(logical_qreg[7], logical_qreg[2])
        qcirc.cx(logical_qreg[5], logical_qreg[9])
        qcirc.cx(logical_qreg[1], logical_qreg[8])

        qcirc.h(logical_qreg[7])

        return qcirc.to_gate(label="{$S_1^f, \\ S_5^f, \\ S_6^f$}")

    def configure_qec_cycle(self, sample_rate):
        # @TODO - Allow configuration of QEC cycling
        pass

    def perform_qec_cycle(self, qubits=[]):
        if len(qubits) == 0:
            qubits = [q for q in range(len(self.logical_qregs))]

        for q in qubits:
            super().reset(self.ancilla_qregs[q])

            # @TODO - apply first unflagged circuit
