import sys

from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit, AncillaRegister
from qiskit.circuit.classical import expr
from qiskit.quantum_info import Pauli

class LogicalCircuit(QuantumCircuit):
    def __init__(
            self,
            n_logical_qubits,
            stabilizer_tableau = None,
            name: str | None = None,
        ):

        self.n_logical_qubits = n_logical_qubits

        if stabilizer_tableau == None:
            raise ValueError("No stabilizer tableau provided!")
        
        self.n_stabilizers = len(stabilizer_tableau)
        self.n_physical_qubits = len(stabilizer_tableau[0])
        self.n_ancilla_qubits = self.n_stabilizers//2
        self.n_measure_qubits = self.n_ancilla_qubits
        self.encoding_gate = self.__encode_gate()
        self.stabilizers = stabilizer_tableau
        self.flagged_stabilizers_1 = []
        self.flagged_stabilizers_2 = []
        self.x_stabilizers = []
        self.z_stabilizers = []

        self.logical_qregs = []
        self.ancilla_qregs = []
        self.enc_verif_cregs = []
        self.current_syndrome_cregs = []
        self.prev_syndrome_cregs = []
        self.flagged_syndrome_diff_cregs = []
        self.unflagged_syndrome_diff_cregs = []
        self.pauli_frame_cregs = []
        self.final_measurement_cregs = []

        # The full circuit is generated by calling super()
        super().__init__(name=name)
        self.add_logical_qubits(self.n_logical_qubits)
        self.group_stabilizers()

        # @TODO - find alternative, possibly by implementing upstream
        # Create setter qreg for purpose of setting classical bits dynamically
        self.cbit_setter_qreg = QuantumRegister(2, name="qsetter")
        self.add_register(self.cbit_setter_qreg)
        super().x(self.cbit_setter_qreg[1])

        
    def add_logical_qubits(self, logical_qubit_count):
        current_logical_qubit_count = len(self.logical_qregs)

        for i in range(current_logical_qubit_count, current_logical_qubit_count + logical_qubit_count):
            # Physical qubits for logical qubit
            logical_qreg_i = QuantumRegister(self.n_physical_qubits, name=f"qlog{i}")
            # Ancilla qubits needed for measurements
            ancilla_qreg_i = AncillaRegister(self.n_ancilla_qubits, name=f"qanc{i}")
            # Classical bits needed for encoding verification
            enc_verif_creg_i = ClassicalRegister(1, name=f"cenc_verif{i}")
            # Classical bits needed for measurements
            current_syndrome_creg_i = ClassicalRegister(self.n_measure_qubits, name=f"ccurr_syndrome{i}")
            # Classical bits needed for previous syndrome measurements
            prev_syndrome_creg_i = ClassicalRegister(self.n_stabilizers, name=f"cprev_syndrome{i}")
            # Classical bits needed for flagged syndrome difference measurements
            flagged_syndrome_diff_creg_i = ClassicalRegister(self.n_stabilizers, name=f"cflagged_syndrome_diff{i}")
            # Classical bits needed for unflagged syndrome difference measurements
            unflagged_syndrome_diff_creg_i = ClassicalRegister(self.n_stabilizers, name=f"cunflagged_syndrome_diff{i}")
            # Classical bits needed to track the Pauli Frame
            pauli_frame_creg_i = ClassicalRegister(2, name=f"pauli_frame{i}")
            # Classical bits needed to take measurements of the final state of the logical qubit
            final_measurement_creg_i = ClassicalRegister(self.n_physical_qubits, name=f"final_meas{i}")

            # Add new registers to storage lists
            self.logical_qregs.append(logical_qreg_i)
            self.ancilla_qregs.append(ancilla_qreg_i)
            self.enc_verif_cregs.append(enc_verif_creg_i)
            self.current_syndrome_cregs.append(current_syndrome_creg_i)
            self.prev_syndrome_cregs.append(prev_syndrome_creg_i)
            self.flagged_syndrome_diff_cregs.append(flagged_syndrome_diff_creg_i)
            self.unflagged_syndrome_diff_cregs.append(unflagged_syndrome_diff_creg_i)
            self.pauli_frame_cregs.append(pauli_frame_creg_i)
            self.final_measurement_cregs.append(final_measurement_creg_i)
            

            # Add new registers to quantum circuit
            super().add_register(logical_qreg_i)
            super().add_register(ancilla_qreg_i)
            super().add_register(enc_verif_creg_i)
            super().add_register(current_syndrome_creg_i)
            super().add_register(prev_syndrome_creg_i)
            super().add_register(flagged_syndrome_diff_creg_i)
            super().add_register(unflagged_syndrome_diff_creg_i)
            super().add_register(pauli_frame_creg_i)
            super().add_register(final_measurement_creg_i)


    ############################################
    ##### Quantum error correction methods #####
    ############################################

    def group_stabilizers(self):
        # @TODO - determine how stabilizers are selected for flagged measurements
        self.flagged_stabilizers_1 = [0, 4, 5]
        self.flagged_stabilizers_2 = [1, 2, 3]

        for i in range(self.n_stabilizers):
            if 'X' in self.stabilizers[i]:
                self.x_stabilizers.append(i)
            if 'Z' in self.stabilizers[i]:
                self.z_stabilizers.append(i)

    #Returns a gate used for encoding 
    def __encode_gate(self):
        qc = QuantumCircuit(self.n_physical_qubits)
        qc.h(0)
        qc.h(4)
        qc.h(6)
        qc.cx(0, 1)
        qc.cx(4, 5)
        qc.cx(6, 3)
        qc.cx(6, 5)
        qc.cx(4, 2)
        qc.cx(0, 3)
        qc.cx(4, 1)
        qc.cx(3, 2)

        return qc.to_gate(label="encode")

    #Encodes logical qubits for a given number of iterations
    def encode(self, *qubits, max_iterations=1, initial_states=[]):
        """
        Prepare logical qubit(s) in the specified initial state
        """
        
        if len(initial_states) > 0 and len(qubits) != len(initial_states):
            raise ValueError("Number of qubits should equal number of initial states if initial states are provided")
        for q in qubits:
            # Preliminary physical qubit reset
            super().reset(self.logical_qregs[q])
            
            # Initial encoding
            super().append(self.encoding_gate, self.logical_qregs[q][:7])

            # CNOT from (Z1 Z3 Z5) to ancilla
            super().cx(self.logical_qregs[q][1], self.ancilla_qregs[q][0])
            super().cx(self.logical_qregs[q][3], self.ancilla_qregs[q][0])
            super().cx(self.logical_qregs[q][5], self.ancilla_qregs[q][0])

            # Measure ancilla
            super().measure(self.ancilla_qregs[q][0], self.enc_verif_cregs[q][0])

            for _ in range(max_iterations - 1):
                # If the ancilla stores a 1, reset the entire logical qubit and redo
                with super().if_test((self.enc_verif_cregs[q][0], 1)):
                    super().reset(self.logical_qregs[q])

                    # Initial encoding
                    super().append(self.encoding_gate, self.logical_qregs[q])

                    # CNOT from (Z1 Z3 Z5) to ancilla
                    super().cx(self.logical_qregs[q][1], self.ancilla_qregs[q][0])
                    super().cx(self.logical_qregs[q][3], self.ancilla_qregs[q][0])
                    super().cx(self.logical_qregs[q][5], self.ancilla_qregs[q][0])

                    # Measure ancilla
                    super().measure(self.ancilla_qregs[q][0], self.enc_verif_cregs[q][0])
        
            # Reset ancilla qubit
            super().reset(self.ancilla_qregs[q][0])

        # Flip qubits if necessary
        for initial_state in initial_states:
            if initial_state == 1:
                super().x(self.logical_qregs[q][:7])
            elif initial_state != 0:
                raise ValueError("Initial state should be either 0 or 1 (arbitrary statevectors not yet supported)!")
            
        self.barrier()
        
        return True

    # Measure flagged or unflagged syndrome differences for specified logical qubits and stabilizers
    def measure_syndrome_diff(self, logical_qubit_indices=[], stabilizer_indices=[], flagged=False):
        if len(logical_qubit_indices) == 0:
            logical_qubit_indices = list(range(self.n_logical_qubits))
        
        if len(stabilizer_indices) == 0:
            stabilizer_indices = list(range(self.n_stabilizers))

        for q in logical_qubit_indices:
            syndrome_diff_creg = self.flagged_syndrome_diff_cregs[q] if flagged else self.unflagged_syndrome_diff_cregs[q]

            # Apply and measure stabilizers for the desired syndrome
            self.add_stabilizers(q, stabilizer_indices)
            for n in range(self.n_ancilla_qubits):
                super().measure(self.ancilla_qregs[q][n], self.current_syndrome_cregs[q][n])
        
            # Determine the syndrome difference
            for n in range(len(stabilizer_indices)):
                with self.if_test(self.cbit_xor([self.current_syndrome_cregs[q][n], self.prev_syndrome_cregs[q][stabilizer_indices[n]-1]])) as _else:
                    self.set_cbit(syndrome_diff_creg[stabilizer_indices[n]], 1)
                with _else:
                    self.set_cbit(syndrome_diff_creg[stabilizer_indices[n]], 0)
        
        self.barrier()
        self.reset_ancillas(logical_qubit_indices)
        self.barrier()

    # Reset all ancillas associated with specified logical qubits
    def reset_ancillas(self, logical_qubit_indices=[]):
        if len(logical_qubit_indices) == 0:
            logical_qubit_indices = list(range(self.n_logical_qubits))
        
        for q in logical_qubit_indices:
            self.reset(self.ancilla_qregs[q])

    # Add specified specifiers to the circuit as controlled Pauli operators
    def add_stabilizers(self, lq_index, stabilizer_indices=[]):
        if len(stabilizer_indices) == 0:
            stabilizer_indices = list(range(self.n_stabilizers))
        
        for i in range(len(stabilizer_indices)):
            stabilizer = self.stabilizers[stabilizer_indices[i]]

            ztype = False
            if 'Z' in stabilizer:
                ztype = True

            for p, pauli_character in enumerate(stabilizer):
                CPauliInstruction = Pauli(pauli_character).to_instruction().control(1)
                if ztype: 
                    self.append(CPauliInstruction, [self.ancilla_qregs[lq_index][i], self.logical_qregs[lq_index][p]])
                else:
                    self.append(CPauliInstruction, [self.logical_qregs[lq_index][p], self.ancilla_qregs[lq_index][i]])
            
            self.barrier()

    # @TODO - allow configuration of QEC cycling
    def configure_qec_cycle(self, sample_rate):
        raise NotImplementedError("QEC Cycle configuration has not yet been implemented.")

    def perform_qec_cycle(self, logical_qubit_indices=[]):
        if len(logical_qubit_indices) == 0:
            logical_qubit_indices = list(range(self.n_logical_qubits))

        for q in logical_qubit_indices:
            super().reset(self.ancilla_qregs[q])

            # Perform first flagged syndrome measurements
            self.measure_syndrome_diff(logical_qubit_indices, self.flagged_stabilizers_1, flagged=True)
        
            # If no change in syndrome, perform second flagged syndrome measurement
            with self.if_test(expr.equal(self.flagged_syndrome_diff_cregs[q], 0)):
                self.measure_syndrome_diff(logical_qubit_indices, self.flagged_stabilizers_2, flagged=True)
        
            # If change in syndrome, perform unflagged syndrome measurement, decode, and correct
            with self.if_test(expr.not_equal(self.flagged_syndrome_diff_cregs[q], 0)):
                self.measure_syndrome_diff(logical_qubit_indices, self.x_stabilizers, flagged=False)
                self.measure_syndrome_diff(logical_qubit_indices, self.z_stabilizers, flagged=False)
        
                self.apply_decoding(logical_qubit_indices, self.x_stabilizers, with_flagged=False)
                self.apply_decoding(logical_qubit_indices, self.z_stabilizers, with_flagged=False)
                self.apply_decoding(logical_qubit_indices, self.x_stabilizers, with_flagged=True)
                self.apply_decoding(logical_qubit_indices, self.z_stabilizers, with_flagged=True)
        
                # Update previous syndrome
                for n in range(len(self.stabilizers)):
                    with self.if_test(expr.lift(self.unflagged_syndrome_diff_cregs[q][n])):
                        self.cbit_not(self.prev_syndrome_cregs[q][n])

    def apply_decoding(self, logical_qubit_indices, stabilizers, with_flagged):

        for q in logical_qubit_indices:

            syn_diff = [self.unflagged_syndrome_diff_cregs[q][x] for x in stabilizers]
            #Determines index of pauli frame to be modified
            pf_ind = 0 if 'X' in self.stabilizers[stabilizers[0]] else 1

            #Decoding sequence with flagged syndrome
            if with_flagged:
                flag_diff = [self.flagged_syndrome_diff_cregs[q][x] for x in stabilizers]
                with super().if_test(expr.bit_and(self.cbit_and(flag_diff, [1, 0, 0]), self.cbit_and(syn_diff, [0, 1, 0]))):
                    self.cbit_not(self.pauli_frame_cregs[q][pf_ind])
                with super().if_test(expr.bit_and(self.cbit_and(flag_diff, [1, 0, 0]), self.cbit_and(syn_diff, [0, 0, 1]))):
                    self.cbit_not(self.pauli_frame_cregs[q][pf_ind])
                with super().if_test(expr.bit_and(self.cbit_and(flag_diff, [0, 1, 1]), self.cbit_and(syn_diff, [0, 0, 1]))):
                    self.cbit_not(self.pauli_frame_cregs[q][pf_ind])
            
            #Unflagged decoding sequence
            else:
                with super().if_test(self.cbit_and(syn_diff, [0, 1, 0])):
                    self.cbit_not(self.pauli_frame_cregs[q][pf_ind])
                with super().if_test(self.cbit_and(syn_diff, [0, 1, 1])):
                    self.cbit_not(self.pauli_frame_cregs[q][pf_ind])
                with super().if_test(self.cbit_and(syn_diff, [0, 0, 1])):
                    self.cbit_not(self.pauli_frame_cregs[q][pf_ind])

    def measure(self, logical_qubit_indices, cbits):

        if len(logical_qubit_indices) != len(cbits):
            raise ValueError("Number of qubits should equal number of classical bits")
        
        for i in range(len(cbits)):
            q = logical_qubit_indices[i]
            c = cbits[i]

            #Measurement of state
            for n in range(self.n_physical_qubits):
                super().measure(self.logical_qregs[q][n], self.final_measurement_cregs[q][n])

            with super().if_test(self.cbit_xor([self.final_measurement_cregs[q][x] for x in [4,5,6]])):
                self.set_cbit(c, 1)

            #Final syndrome
            for n in range(self.n_ancilla_qubits):
                stabilizer = self.stabilizers[self.z_stabilizers[n]]
                s_indices = []
                for i in range(len(stabilizer)):
                    if stabilizer[i] == 'Z':
                        s_indices.append(i)

                with super().if_test(self.cbit_xor([self.final_measurement_cregs[q][x] for x in s_indices])):
                    self.set_cbit(self.current_syndrome_cregs[q][n], 1)

            #Final syndrome diff
            for n in range(self.n_ancilla_qubits):
                with super().if_test(self.cbit_xor([self.current_syndrome_cregs[q][n], self.prev_syndrome_cregs[q][self.z_stabilizers[n]]])) as _else:
                    self.set_cbit(self.unflagged_syndrome_diff_cregs[q][self.z_stabilizers[n]], 1)
                with _else:
                    self.set_cbit(self.unflagged_syndrome_diff_cregs[q][self.z_stabilizers[n]], 1)

            #Final correction
            self.apply_decoding([q], self.z_stabilizers, with_flagged=False)
            with super().if_test(expr.lift(self.pauli_frame_cregs[q][0])):
                self.cbit_not(c)

    #Adds a desired error for testing
    def add_error(self, l_ind, p_ind, type):
        if type == 'X':
            super().x(self.logical_qregs[l_ind][p_ind])
        if type == 'Z':
            super().z(self.logical_qregs[l_ind][p_ind])
        

    # Set values of classical bits
    def set_cbit(self, cbit, value):
        if value == 0:
            super().measure(self.cbit_setter_qreg[0], cbit)
        else:
            super().measure(self.cbit_setter_qreg[1], cbit)

    # Performs a NOT statement on a classical bit
    def cbit_not(self, cbit):
        with self.if_test(expr.lift(cbit)) as _else:
            self.set_cbit(cbit, 0)
        with _else:
            self.set_cbit(cbit, 1)
    
    # Performs AND and NOT statements on multiple classical bits, e.g. (~c[0] & ~c[1] & c[2])
    def cbit_and(self, cbits, values):
        result = expr.bit_not(cbits[0]) if values[0] == 0 else expr.lift(cbits[0])
        for n in range(len(cbits)-1):
            result = expr.bit_and(result, expr.bit_not(cbits[n+1])) if values[n+1] == 0 else expr.bit_and(result, cbits[n+1])
        return result
    
    # XOR multiple classical bits
    def cbit_xor(self, cbits):
        result = expr.lift(cbits[0])
        for n in range(len(cbits)-1):
            result = expr.bit_xor(result, cbits[n+1])
        return result

    ######################################
    ##### Logical Quantum Operations #####
    ######################################

    def h(self, *targets):
        """
        Logical Hadamard operation
        """

        for t in targets:
            super().h(self.logical_qregs[t][4:7])
    
    def x(self, *targets):
        """
        Logical PauliX operation
        """

        for t in targets:
            super().x(self.logical_qregs[t][4:7])
    
    def y(self, *targets):
        """
        Logical PauliY operation
        """

        for t in targets:
            super().y(self.logical_qregs[t][4:7])
    
    def z(self, *targets):
        """
        Logical PauliZ operation
        """

        for t in targets:
            super().z(self.logical_qregs[t][4:7])
    
    def s(self, *targets):
        """
        Logical phase gate operation
        """

        for t in targets:
            super().s(self.logical_qregs[t][4:7])
            super().s(self.logical_qregs[t][4:7])
            super().s(self.logical_qregs[t][4:7])
    
    def cx(self, control, *targets):
        """
        Logical Controlled-PauliX operation
        """

        for t in targets:
            super().cx(self.logical_qregs[control], self.logical_qregs[t][4:7])

